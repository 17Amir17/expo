diff --git a/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js b/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js
index f2e4646..59e4f97 100644
--- a/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js
+++ b/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js
@@ -10,217 +10,229 @@
 
 'use strict';
 
-if (process.env.NODE_ENV !== "production") {
-  (function() {
-'use strict';
+// if (process.env.NODE_ENV !== "production") {
+(function () {
+  'use strict';
 
-var ReactDOM = require('react-dom');
-var React = require('react');
-
-// -----------------------------------------------------------------------------
-var enableBinaryFlight = false;
-
-function createStringDecoder() {
-  return new TextDecoder();
-}
-var decoderOptions = {
-  stream: true
-};
-function readPartialStringChunk(decoder, buffer) {
-  return decoder.decode(buffer, decoderOptions);
-}
-function readFinalStringChunk(decoder, buffer) {
-  return decoder.decode(buffer);
-}
-
-// This is the parsed shape of the wire format which is why it is
-// condensed to only the essentialy information
-var ID = 0;
-var CHUNKS = 1;
-var NAME = 2; // export const ASYNC = 3;
-// This logic is correct because currently only include the 4th tuple member
-// when the module is async. If that changes we will need to actually assert
-// the value is true. We don't index into the 4th slot because flow does not
-// like the potential out of bounds access
-
-function isAsyncImport(metadata) {
-  return metadata.length === 4;
-}
-
-function resolveClientReference(bundlerConfig, metadata) {
-  if (bundlerConfig) {
-    var moduleExports = bundlerConfig[metadata[ID]];
-    var resolvedModuleData = moduleExports[metadata[NAME]];
-    var name;
-
-    if (resolvedModuleData) {
-      // The potentially aliased name.
-      name = resolvedModuleData.name;
-    } else {
-      // If we don't have this specific name, we might have the full module.
-      resolvedModuleData = moduleExports['*'];
+  var ReactDOM = require('react-dom');
+  var React = require('react');
 
-      if (!resolvedModuleData) {
-        throw new Error('Could not find the module "' + metadata[ID] + '" in the React SSR Manifest. ' + 'This is probably a bug in the React Server Components bundler.');
-      }
+  // -----------------------------------------------------------------------------
+  var enableBinaryFlight = false;
 
-      name = metadata[NAME];
-    }
+  function createStringDecoder() {
+    return new TextDecoder();
+  }
+  var decoderOptions = {
+    stream: true,
+  };
+  function readPartialStringChunk(decoder, buffer) {
+    return decoder.decode(buffer, decoderOptions);
+  }
+  function readFinalStringChunk(decoder, buffer) {
+    return decoder.decode(buffer);
+  }
 
-    if (isAsyncImport(metadata)) {
-      return [resolvedModuleData.id, resolvedModuleData.chunks, name, 1
-      /* async */
-      ];
-    } else {
-      return [resolvedModuleData.id, resolvedModuleData.chunks, name];
-    }
+  // This is the parsed shape of the wire format which is why it is
+  // condensed to only the essentialy information
+  var ID = 0;
+  var CHUNKS = 1;
+  var NAME = 2; // export const ASYNC = 3;
+  // This logic is correct because currently only include the 4th tuple member
+  // when the module is async. If that changes we will need to actually assert
+  // the value is true. We don't index into the 4th slot because flow does not
+  // like the potential out of bounds access
+
+  function isAsyncImport(metadata) {
+    return metadata.length === 4;
   }
 
-  return metadata;
-}
-// If they're still pending they're a thenable. This map also exists
-// in Webpack but unfortunately it's not exposed so we have to
-// replicate it in user space. null means that it has already loaded.
+  function resolveClientReference(bundlerConfig, metadata) {
+    if (bundlerConfig) {
+      var moduleExports = bundlerConfig[metadata[ID]];
+      var resolvedModuleData = moduleExports[metadata[NAME]];
+      var name;
+
+      if (resolvedModuleData) {
+        // The potentially aliased name.
+        name = resolvedModuleData.name;
+      } else {
+        // If we don't have this specific name, we might have the full module.
+        resolvedModuleData = moduleExports['*'];
+
+        if (!resolvedModuleData) {
+          throw new Error(
+            'Could not find the module "' +
+              metadata[ID] +
+              '" in the React SSR Manifest. ' +
+              'This is probably a bug in the React Server Components bundler.'
+          );
+        }
 
-var chunkCache = new Map();
+        name = metadata[NAME];
+      }
 
-function requireAsyncModule(id) {
-  // We've already loaded all the chunks. We can require the module.
-  var promise = __webpack_require__(id);
+      if (isAsyncImport(metadata)) {
+        return [
+          resolvedModuleData.id,
+          resolvedModuleData.chunks,
+          name,
+          1,
+          /* async */
+        ];
+      } else {
+        return [resolvedModuleData.id, resolvedModuleData.chunks, name];
+      }
+    }
 
-  if (typeof promise.then !== 'function') {
-    // This wasn't a promise after all.
-    return null;
-  } else if (promise.status === 'fulfilled') {
-    // This module was already resolved earlier.
-    return null;
-  } else {
-    // Instrument the Promise to stash the result.
-    promise.then(function (value) {
-      var fulfilledThenable = promise;
-      fulfilledThenable.status = 'fulfilled';
-      fulfilledThenable.value = value;
-    }, function (reason) {
-      var rejectedThenable = promise;
-      rejectedThenable.status = 'rejected';
-      rejectedThenable.reason = reason;
-    });
-    return promise;
+    return metadata;
   }
-}
-
-function ignoreReject() {// We rely on rejected promises to be handled by another listener.
-} // Start preloading the modules since we might need them soon.
-// This function doesn't suspend.
-
+  // If they're still pending they're a thenable. This map also exists
+  // in Webpack but unfortunately it's not exposed so we have to
+  // replicate it in user space. null means that it has already loaded.
 
-function preloadModule(metadata) {
-  var chunks = metadata[CHUNKS];
-  var promises = [];
-  var i = 0;
+  var chunkCache = new Map();
 
-  while (i < chunks.length) {
-    var chunkId = chunks[i++];
-    var chunkFilename = chunks[i++];
-    var entry = chunkCache.get(chunkId);
+  function requireAsyncModule(id) {
+    // We've already loaded all the chunks. We can require the module.
+    var promise = __webpack_require__(id);
 
-    if (entry === undefined) {
-      var thenable = loadChunk(chunkId, chunkFilename);
-      promises.push(thenable); // $FlowFixMe[method-unbinding]
-
-      var resolve = chunkCache.set.bind(chunkCache, chunkId, null);
-      thenable.then(resolve, ignoreReject);
-      chunkCache.set(chunkId, thenable);
-    } else if (entry !== null) {
-      promises.push(entry);
+    if (typeof promise.then !== 'function') {
+      // This wasn't a promise after all.
+      return null;
+    } else if (promise.status === 'fulfilled') {
+      // This module was already resolved earlier.
+      return null;
+    } else {
+      // Instrument the Promise to stash the result.
+      promise.then(
+        function (value) {
+          var fulfilledThenable = promise;
+          fulfilledThenable.status = 'fulfilled';
+          fulfilledThenable.value = value;
+        },
+        function (reason) {
+          var rejectedThenable = promise;
+          rejectedThenable.status = 'rejected';
+          rejectedThenable.reason = reason;
+        }
+      );
+      return promise;
     }
   }
 
-  if (isAsyncImport(metadata)) {
-    if (promises.length === 0) {
-      return requireAsyncModule(metadata[ID]);
-    } else {
-      return Promise.all(promises).then(function () {
+  function ignoreReject() {
+    // We rely on rejected promises to be handled by another listener.
+  } // Start preloading the modules since we might need them soon.
+  // This function doesn't suspend.
+
+  function preloadModule(metadata) {
+    var chunks = metadata[CHUNKS];
+    var promises = [];
+    var i = 0;
+
+    while (i < chunks.length) {
+      var chunkId = chunks[i++];
+      var chunkFilename = chunks[i++];
+      var entry = chunkCache.get(chunkId);
+
+      if (entry === undefined) {
+        var thenable = loadChunk(chunkId, chunkFilename);
+        promises.push(thenable); // $FlowFixMe[method-unbinding]
+
+        var resolve = chunkCache.set.bind(chunkCache, chunkId, null);
+        thenable.then(resolve, ignoreReject);
+        chunkCache.set(chunkId, thenable);
+      } else if (entry !== null) {
+        promises.push(entry);
+      }
+    }
+
+    if (isAsyncImport(metadata)) {
+      if (promises.length === 0) {
         return requireAsyncModule(metadata[ID]);
-      });
+      } else {
+        return Promise.all(promises).then(function () {
+          return requireAsyncModule(metadata[ID]);
+        });
+      }
+    } else if (promises.length > 0) {
+      return Promise.all(promises);
+    } else {
+      return null;
     }
-  } else if (promises.length > 0) {
-    return Promise.all(promises);
-  } else {
-    return null;
-  }
-} // Actually require the module or suspend if it's not yet ready.
-// Increase priority if necessary.
+  } // Actually require the module or suspend if it's not yet ready.
+  // Increase priority if necessary.
 
-function requireModule(metadata) {
-  var moduleExports = __webpack_require__(metadata[ID]);
+  function requireModule(metadata) {
+    var moduleExports = __webpack_require__(metadata[ID]);
+    console.log('__webpack_require__', __webpack_require__, metadata, ID);
 
-  if (isAsyncImport(metadata)) {
-    if (typeof moduleExports.then !== 'function') ; else if (moduleExports.status === 'fulfilled') {
-      // This Promise should've been instrumented by preloadModule.
-      moduleExports = moduleExports.value;
-    } else {
-      throw moduleExports.reason;
+    if (isAsyncImport(metadata)) {
+      if (typeof moduleExports.then !== 'function');
+      else if (moduleExports.status === 'fulfilled') {
+        // This Promise should've been instrumented by preloadModule.
+        moduleExports = moduleExports.value;
+      } else {
+        throw moduleExports.reason;
+      }
     }
-  }
 
-  if (metadata[NAME] === '*') {
-    // This is a placeholder value that represents that the caller imported this
-    // as a CommonJS module as is.
-    return moduleExports;
-  }
+    if (metadata[NAME] === '*') {
+      // This is a placeholder value that represents that the caller imported this
+      // as a CommonJS module as is.
+      return moduleExports;
+    }
 
-  if (metadata[NAME] === '') {
-    // This is a placeholder value that represents that the caller accessed the
-    // default property of this if it was an ESM interop module.
-    return moduleExports.__esModule ? moduleExports.default : moduleExports;
-  }
+    if (metadata[NAME] === '') {
+      // This is a placeholder value that represents that the caller accessed the
+      // default property of this if it was an ESM interop module.
+      return moduleExports.__esModule ? moduleExports.default : moduleExports;
+    }
 
-  return moduleExports[metadata[NAME]];
-}
+    return moduleExports[metadata[NAME]];
+  }
 
-var chunkMap = new Map();
-/**
- * We patch the chunk filename function in webpack to insert our own resolution
- * of chunks that come from Flight and may not be known to the webpack runtime
- */
+  var chunkMap = new Map();
+  /**
+   * We patch the chunk filename function in webpack to insert our own resolution
+   * of chunks that come from Flight and may not be known to the webpack runtime
+   */
 
-var webpackGetChunkFilename = __webpack_require__.u;
+  var webpackGetChunkFilename = __webpack_require__.u;
 
-__webpack_require__.u = function (chunkId) {
-  var flightChunk = chunkMap.get(chunkId);
+  __webpack_require__.u = function (chunkId) {
+    var flightChunk = chunkMap.get(chunkId);
 
-  if (flightChunk !== undefined) {
-    return flightChunk;
-  }
+    if (flightChunk !== undefined) {
+      return flightChunk;
+    }
 
-  return webpackGetChunkFilename(chunkId);
-};
+    return webpackGetChunkFilename(chunkId);
+  };
 
-function loadChunk(chunkId, filename) {
-  chunkMap.set(chunkId, filename);
-  return __webpack_chunk_load__(chunkId);
-}
+  function loadChunk(chunkId, filename) {
+    chunkMap.set(chunkId, filename);
+    return __webpack_chunk_load__(chunkId);
+  }
 
-var ReactDOMSharedInternals = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
+  var ReactDOMSharedInternals = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
 
-// This client file is in the shared folder because it applies to both SSR and browser contexts.
-var ReactDOMCurrentDispatcher = ReactDOMSharedInternals.Dispatcher;
-function dispatchHint(code, model) {
-  var dispatcher = ReactDOMCurrentDispatcher.current;
+  // This client file is in the shared folder because it applies to both SSR and browser contexts.
+  var ReactDOMCurrentDispatcher = ReactDOMSharedInternals.Dispatcher;
+  function dispatchHint(code, model) {
+    var dispatcher = ReactDOMCurrentDispatcher.current;
 
-  if (dispatcher) {
-    switch (code) {
-      case 'D':
-        {
+    if (dispatcher) {
+      switch (code) {
+        case 'D': {
           var refined = refineModel(code, model);
           var href = refined;
           dispatcher.prefetchDNS(href);
           return;
         }
 
-      case 'C':
-        {
+        case 'C': {
           var _refined = refineModel(code, model);
 
           if (typeof _refined === 'string') {
@@ -235,8 +247,7 @@ function dispatchHint(code, model) {
           return;
         }
 
-      case 'L':
-        {
+        case 'L': {
           var _refined2 = refineModel(code, model);
 
           var _href3 = _refined2[0];
@@ -252,8 +263,7 @@ function dispatchHint(code, model) {
           return;
         }
 
-      case 'm':
-        {
+        case 'm': {
           var _refined3 = refineModel(code, model);
 
           if (typeof _refined3 === 'string') {
@@ -268,8 +278,7 @@ function dispatchHint(code, model) {
           return;
         }
 
-      case 'S':
-        {
+        case 'S': {
           var _refined4 = refineModel(code, model);
 
           if (typeof _refined4 === 'string') {
@@ -287,8 +296,7 @@ function dispatchHint(code, model) {
           return;
         }
 
-      case 'X':
-        {
+        case 'X': {
           var _refined5 = refineModel(code, model);
 
           if (typeof _refined5 === 'string') {
@@ -303,8 +311,7 @@ function dispatchHint(code, model) {
           return;
         }
 
-      case 'M':
-        {
+        case 'M': {
           var _refined6 = refineModel(code, model);
 
           if (typeof _refined6 === 'string') {
@@ -318,174 +325,176 @@ function dispatchHint(code, model) {
 
           return;
         }
+      }
     }
-  }
-} // Flow is having trouble refining the HintModels so we help it a bit.
-// This should be compiled out in the production build.
+  } // Flow is having trouble refining the HintModels so we help it a bit.
+  // This should be compiled out in the production build.
 
-function refineModel(code, model) {
-  return model;
-}
+  function refineModel(code, model) {
+    return model;
+  }
 
-var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
+  var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
 
-function error(format) {
-  {
+  function error(format) {
     {
-      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
-        args[_key2 - 1] = arguments[_key2];
-      }
+      {
+        for (
+          var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;
+          _key2 < _len2;
+          _key2++
+        ) {
+          args[_key2 - 1] = arguments[_key2];
+        }
 
-      printWarning('error', format, args);
+        printWarning('error', format, args);
+      }
     }
   }
-}
-
-function printWarning(level, format, args) {
-  // When changing this logic, you might want to also
-  // update consoleWithStackDev.www.js as well.
-  {
-    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
-    var stack = ReactDebugCurrentFrame.getStackAddendum();
-
-    if (stack !== '') {
-      format += '%s';
-      args = args.concat([stack]);
-    } // eslint-disable-next-line react-internal/safe-string-coercion
-
-
-    var argsWithFormat = args.map(function (item) {
-      return String(item);
-    }); // Careful: RN currently depends on this prefix
-
-    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
-    // breaks IE9: https://github.com/facebook/react/issues/13610
-    // eslint-disable-next-line react-internal/no-production-logging
-
-    Function.prototype.apply.call(console[level], console, argsWithFormat);
-  }
-}
-
-// ATTENTION
-// When adding new symbols to this file,
-// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
-// The Symbol used to tag the ReactElement-like types.
-var REACT_ELEMENT_TYPE = Symbol.for('react.element');
-var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
-var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
-var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
-var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
-var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
-var REACT_MEMO_TYPE = Symbol.for('react.memo');
-var REACT_LAZY_TYPE = Symbol.for('react.lazy');
-var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
-var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
-var FAUX_ITERATOR_SYMBOL = '@@iterator';
-function getIteratorFn(maybeIterable) {
-  if (maybeIterable === null || typeof maybeIterable !== 'object') {
-    return null;
-  }
 
-  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
+  function printWarning(level, format, args) {
+    // When changing this logic, you might want to also
+    // update consoleWithStackDev.www.js as well.
+    {
+      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
+      var stack = ReactDebugCurrentFrame.getStackAddendum();
 
-  if (typeof maybeIterator === 'function') {
-    return maybeIterator;
-  }
+      if (stack !== '') {
+        format += '%s';
+        args = args.concat([stack]);
+      } // eslint-disable-next-line react-internal/safe-string-coercion
 
-  return null;
-}
+      var argsWithFormat = args.map(function (item) {
+        return String(item);
+      }); // Careful: RN currently depends on this prefix
 
-var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare
+      argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
+      // breaks IE9: https://github.com/facebook/react/issues/13610
+      // eslint-disable-next-line react-internal/no-production-logging
 
-function isArray(a) {
-  return isArrayImpl(a);
-}
+      Function.prototype.apply.call(console[level], console, argsWithFormat);
+    }
+  }
 
-var getPrototypeOf = Object.getPrototypeOf;
+  // ATTENTION
+  // When adding new symbols to this file,
+  // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
+  // The Symbol used to tag the ReactElement-like types.
+  var REACT_ELEMENT_TYPE = Symbol.for('react.element');
+  var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
+  var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
+  var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
+  var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
+  var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
+  var REACT_MEMO_TYPE = Symbol.for('react.memo');
+  var REACT_LAZY_TYPE = Symbol.for('react.lazy');
+  var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
+  var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
+  var FAUX_ITERATOR_SYMBOL = '@@iterator';
+  function getIteratorFn(maybeIterable) {
+    if (maybeIterable === null || typeof maybeIterable !== 'object') {
+      return null;
+    }
 
-// in case they error.
+    var maybeIterator =
+      (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
+      maybeIterable[FAUX_ITERATOR_SYMBOL];
 
-var jsxPropsParents = new WeakMap();
-var jsxChildrenParents = new WeakMap();
+    if (typeof maybeIterator === 'function') {
+      return maybeIterator;
+    }
 
-function isObjectPrototype(object) {
-  if (!object) {
-    return false;
+    return null;
   }
 
-  var ObjectPrototype = Object.prototype;
+  var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare
 
-  if (object === ObjectPrototype) {
-    return true;
-  } // It might be an object from a different Realm which is
-  // still just a plain simple object.
+  function isArray(a) {
+    return isArrayImpl(a);
+  }
 
+  var getPrototypeOf = Object.getPrototypeOf;
 
-  if (getPrototypeOf(object)) {
-    return false;
-  }
+  // in case they error.
 
-  var names = Object.getOwnPropertyNames(object);
+  var jsxPropsParents = new WeakMap();
+  var jsxChildrenParents = new WeakMap();
 
-  for (var i = 0; i < names.length; i++) {
-    if (!(names[i] in ObjectPrototype)) {
+  function isObjectPrototype(object) {
+    if (!object) {
       return false;
     }
-  }
 
-  return true;
-}
+    var ObjectPrototype = Object.prototype;
 
-function isSimpleObject(object) {
-  if (!isObjectPrototype(getPrototypeOf(object))) {
-    return false;
-  }
+    if (object === ObjectPrototype) {
+      return true;
+    } // It might be an object from a different Realm which is
+    // still just a plain simple object.
+
+    if (getPrototypeOf(object)) {
+      return false;
+    }
 
-  var names = Object.getOwnPropertyNames(object);
+    var names = Object.getOwnPropertyNames(object);
 
-  for (var i = 0; i < names.length; i++) {
-    var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);
+    for (var i = 0; i < names.length; i++) {
+      if (!(names[i] in ObjectPrototype)) {
+        return false;
+      }
+    }
+
+    return true;
+  }
 
-    if (!descriptor) {
+  function isSimpleObject(object) {
+    if (!isObjectPrototype(getPrototypeOf(object))) {
       return false;
     }
 
-    if (!descriptor.enumerable) {
-      if ((names[i] === 'key' || names[i] === 'ref') && typeof descriptor.get === 'function') {
-        // React adds key and ref getters to props objects to issue warnings.
-        // Those getters will not be transferred to the client, but that's ok,
-        // so we'll special case them.
-        continue;
+    var names = Object.getOwnPropertyNames(object);
+
+    for (var i = 0; i < names.length; i++) {
+      var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);
+
+      if (!descriptor) {
+        return false;
       }
 
-      return false;
+      if (!descriptor.enumerable) {
+        if ((names[i] === 'key' || names[i] === 'ref') && typeof descriptor.get === 'function') {
+          // React adds key and ref getters to props objects to issue warnings.
+          // Those getters will not be transferred to the client, but that's ok,
+          // so we'll special case them.
+          continue;
+        }
+
+        return false;
+      }
     }
+
+    return true;
+  }
+  function objectName(object) {
+    // $FlowFixMe[method-unbinding]
+    var name = Object.prototype.toString.call(object);
+    return name.replace(/^\[object (.*)\]$/, function (m, p0) {
+      return p0;
+    });
   }
 
-  return true;
-}
-function objectName(object) {
-  // $FlowFixMe[method-unbinding]
-  var name = Object.prototype.toString.call(object);
-  return name.replace(/^\[object (.*)\]$/, function (m, p0) {
-    return p0;
-  });
-}
-
-function describeKeyForErrorMessage(key) {
-  var encodedKey = JSON.stringify(key);
-  return '"' + key + '"' === encodedKey ? key : encodedKey;
-}
-
-function describeValueForErrorMessage(value) {
-  switch (typeof value) {
-    case 'string':
-      {
+  function describeKeyForErrorMessage(key) {
+    var encodedKey = JSON.stringify(key);
+    return '"' + key + '"' === encodedKey ? key : encodedKey;
+  }
+
+  function describeValueForErrorMessage(value) {
+    switch (typeof value) {
+      case 'string': {
         return JSON.stringify(value.length <= 10 ? value : value.slice(0, 10) + '...');
       }
 
-    case 'object':
-      {
+      case 'object': {
         if (isArray(value)) {
           return '[...]';
         }
@@ -499,38 +508,37 @@ function describeValueForErrorMessage(value) {
         return name;
       }
 
-    case 'function':
-      return 'function';
+      case 'function':
+        return 'function';
 
-    default:
-      // eslint-disable-next-line react-internal/safe-string-coercion
-      return String(value);
+      default:
+        // eslint-disable-next-line react-internal/safe-string-coercion
+        return String(value);
+    }
   }
-}
 
-function describeElementType(type) {
-  if (typeof type === 'string') {
-    return type;
-  }
+  function describeElementType(type) {
+    if (typeof type === 'string') {
+      return type;
+    }
 
-  switch (type) {
-    case REACT_SUSPENSE_TYPE:
-      return 'Suspense';
+    switch (type) {
+      case REACT_SUSPENSE_TYPE:
+        return 'Suspense';
 
-    case REACT_SUSPENSE_LIST_TYPE:
-      return 'SuspenseList';
-  }
+      case REACT_SUSPENSE_LIST_TYPE:
+        return 'SuspenseList';
+    }
 
-  if (typeof type === 'object') {
-    switch (type.$$typeof) {
-      case REACT_FORWARD_REF_TYPE:
-        return describeElementType(type.render);
+    if (typeof type === 'object') {
+      switch (type.$$typeof) {
+        case REACT_FORWARD_REF_TYPE:
+          return describeElementType(type.render);
 
-      case REACT_MEMO_TYPE:
-        return describeElementType(type.type);
+        case REACT_MEMO_TYPE:
+          return describeElementType(type.type);
 
-      case REACT_LAZY_TYPE:
-        {
+        case REACT_LAZY_TYPE: {
           var lazyComponent = type;
           var payload = lazyComponent._payload;
           var init = lazyComponent._init;
@@ -540,1016 +548,1052 @@ function describeElementType(type) {
             return describeElementType(init(payload));
           } catch (x) {}
         }
+      }
     }
-  }
-
-  return '';
-}
-
-function describeObjectForErrorMessage(objectOrArray, expandedName) {
-  var objKind = objectName(objectOrArray);
 
-  if (objKind !== 'Object' && objKind !== 'Array') {
-    return objKind;
+    return '';
   }
 
-  var str = '';
-  var start = -1;
-  var length = 0;
+  function describeObjectForErrorMessage(objectOrArray, expandedName) {
+    var objKind = objectName(objectOrArray);
 
-  if (isArray(objectOrArray)) {
-    if (jsxChildrenParents.has(objectOrArray)) {
-      // Print JSX Children
-      var type = jsxChildrenParents.get(objectOrArray);
-      str = '<' + describeElementType(type) + '>';
-      var array = objectOrArray;
+    if (objKind !== 'Object' && objKind !== 'Array') {
+      return objKind;
+    }
 
-      for (var i = 0; i < array.length; i++) {
-        var value = array[i];
-        var substr = void 0;
+    var str = '';
+    var start = -1;
+    var length = 0;
+
+    if (isArray(objectOrArray)) {
+      if (jsxChildrenParents.has(objectOrArray)) {
+        // Print JSX Children
+        var type = jsxChildrenParents.get(objectOrArray);
+        str = '<' + describeElementType(type) + '>';
+        var array = objectOrArray;
+
+        for (var i = 0; i < array.length; i++) {
+          var value = array[i];
+          var substr = void 0;
+
+          if (typeof value === 'string') {
+            substr = value;
+          } else if (typeof value === 'object' && value !== null) {
+            substr = '{' + describeObjectForErrorMessage(value) + '}';
+          } else {
+            substr = '{' + describeValueForErrorMessage(value) + '}';
+          }
 
-        if (typeof value === 'string') {
-          substr = value;
-        } else if (typeof value === 'object' && value !== null) {
-          substr = '{' + describeObjectForErrorMessage(value) + '}';
-        } else {
-          substr = '{' + describeValueForErrorMessage(value) + '}';
+          if ('' + i === expandedName) {
+            start = str.length;
+            length = substr.length;
+            str += substr;
+          } else if (substr.length < 15 && str.length + substr.length < 40) {
+            str += substr;
+          } else {
+            str += '{...}';
+          }
         }
 
-        if ('' + i === expandedName) {
-          start = str.length;
-          length = substr.length;
-          str += substr;
-        } else if (substr.length < 15 && str.length + substr.length < 40) {
-          str += substr;
-        } else {
-          str += '{...}';
-        }
-      }
+        str += '</' + describeElementType(type) + '>';
+      } else {
+        // Print Array
+        str = '[';
+        var _array = objectOrArray;
 
-      str += '</' + describeElementType(type) + '>';
-    } else {
-      // Print Array
-      str = '[';
-      var _array = objectOrArray;
+        for (var _i = 0; _i < _array.length; _i++) {
+          if (_i > 0) {
+            str += ', ';
+          }
 
-      for (var _i = 0; _i < _array.length; _i++) {
-        if (_i > 0) {
-          str += ', ';
-        }
+          var _value = _array[_i];
 
-        var _value = _array[_i];
+          var _substr = void 0;
 
-        var _substr = void 0;
+          if (typeof _value === 'object' && _value !== null) {
+            _substr = describeObjectForErrorMessage(_value);
+          } else {
+            _substr = describeValueForErrorMessage(_value);
+          }
 
-        if (typeof _value === 'object' && _value !== null) {
-          _substr = describeObjectForErrorMessage(_value);
-        } else {
-          _substr = describeValueForErrorMessage(_value);
+          if ('' + _i === expandedName) {
+            start = str.length;
+            length = _substr.length;
+            str += _substr;
+          } else if (_substr.length < 10 && str.length + _substr.length < 40) {
+            str += _substr;
+          } else {
+            str += '...';
+          }
         }
 
-        if ('' + _i === expandedName) {
-          start = str.length;
-          length = _substr.length;
-          str += _substr;
-        } else if (_substr.length < 10 && str.length + _substr.length < 40) {
-          str += _substr;
-        } else {
-          str += '...';
-        }
+        str += ']';
       }
+    } else {
+      if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE) {
+        str = '<' + describeElementType(objectOrArray.type) + '/>';
+      } else if (jsxPropsParents.has(objectOrArray)) {
+        // Print JSX
+        var _type = jsxPropsParents.get(objectOrArray);
+
+        str = '<' + (describeElementType(_type) || '...');
+        var object = objectOrArray;
+        var names = Object.keys(object);
+
+        for (var _i2 = 0; _i2 < names.length; _i2++) {
+          str += ' ';
+          var name = names[_i2];
+          str += describeKeyForErrorMessage(name) + '=';
+          var _value2 = object[name];
+
+          var _substr2 = void 0;
+
+          if (name === expandedName && typeof _value2 === 'object' && _value2 !== null) {
+            _substr2 = describeObjectForErrorMessage(_value2);
+          } else {
+            _substr2 = describeValueForErrorMessage(_value2);
+          }
 
-      str += ']';
-    }
-  } else {
-    if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE) {
-      str = '<' + describeElementType(objectOrArray.type) + '/>';
-    } else if (jsxPropsParents.has(objectOrArray)) {
-      // Print JSX
-      var _type = jsxPropsParents.get(objectOrArray);
-
-      str = '<' + (describeElementType(_type) || '...');
-      var object = objectOrArray;
-      var names = Object.keys(object);
-
-      for (var _i2 = 0; _i2 < names.length; _i2++) {
-        str += ' ';
-        var name = names[_i2];
-        str += describeKeyForErrorMessage(name) + '=';
-        var _value2 = object[name];
-
-        var _substr2 = void 0;
-
-        if (name === expandedName && typeof _value2 === 'object' && _value2 !== null) {
-          _substr2 = describeObjectForErrorMessage(_value2);
-        } else {
-          _substr2 = describeValueForErrorMessage(_value2);
-        }
+          if (typeof _value2 !== 'string') {
+            _substr2 = '{' + _substr2 + '}';
+          }
 
-        if (typeof _value2 !== 'string') {
-          _substr2 = '{' + _substr2 + '}';
+          if (name === expandedName) {
+            start = str.length;
+            length = _substr2.length;
+            str += _substr2;
+          } else if (_substr2.length < 10 && str.length + _substr2.length < 40) {
+            str += _substr2;
+          } else {
+            str += '...';
+          }
         }
 
-        if (name === expandedName) {
-          start = str.length;
-          length = _substr2.length;
-          str += _substr2;
-        } else if (_substr2.length < 10 && str.length + _substr2.length < 40) {
-          str += _substr2;
-        } else {
-          str += '...';
-        }
-      }
+        str += '>';
+      } else {
+        // Print Object
+        str = '{';
+        var _object = objectOrArray;
 
-      str += '>';
-    } else {
-      // Print Object
-      str = '{';
-      var _object = objectOrArray;
+        var _names = Object.keys(_object);
 
-      var _names = Object.keys(_object);
+        for (var _i3 = 0; _i3 < _names.length; _i3++) {
+          if (_i3 > 0) {
+            str += ', ';
+          }
 
-      for (var _i3 = 0; _i3 < _names.length; _i3++) {
-        if (_i3 > 0) {
-          str += ', ';
-        }
+          var _name = _names[_i3];
+          str += describeKeyForErrorMessage(_name) + ': ';
+          var _value3 = _object[_name];
 
-        var _name = _names[_i3];
-        str += describeKeyForErrorMessage(_name) + ': ';
-        var _value3 = _object[_name];
+          var _substr3 = void 0;
 
-        var _substr3 = void 0;
+          if (typeof _value3 === 'object' && _value3 !== null) {
+            _substr3 = describeObjectForErrorMessage(_value3);
+          } else {
+            _substr3 = describeValueForErrorMessage(_value3);
+          }
 
-        if (typeof _value3 === 'object' && _value3 !== null) {
-          _substr3 = describeObjectForErrorMessage(_value3);
-        } else {
-          _substr3 = describeValueForErrorMessage(_value3);
+          if (_name === expandedName) {
+            start = str.length;
+            length = _substr3.length;
+            str += _substr3;
+          } else if (_substr3.length < 10 && str.length + _substr3.length < 40) {
+            str += _substr3;
+          } else {
+            str += '...';
+          }
         }
 
-        if (_name === expandedName) {
-          start = str.length;
-          length = _substr3.length;
-          str += _substr3;
-        } else if (_substr3.length < 10 && str.length + _substr3.length < 40) {
-          str += _substr3;
-        } else {
-          str += '...';
-        }
+        str += '}';
       }
+    }
 
-      str += '}';
+    if (expandedName === undefined) {
+      return str;
     }
-  }
 
-  if (expandedName === undefined) {
-    return str;
-  }
+    if (start > -1 && length > 0) {
+      var highlight = ' '.repeat(start) + '^'.repeat(length);
+      return '\n  ' + str + '\n  ' + highlight;
+    }
 
-  if (start > -1 && length > 0) {
-    var highlight = ' '.repeat(start) + '^'.repeat(length);
-    return '\n  ' + str + '\n  ' + highlight;
+    return '\n  ' + str;
   }
 
-  return '\n  ' + str;
-}
-
-var ObjectPrototype = Object.prototype;
-var knownServerReferences = new WeakMap(); // Serializable values
-// Thenable<ReactServerValue>
-// function serializeByValueID(id: number): string {
-//   return '$' + id.toString(16);
-// }
-
-function serializePromiseID(id) {
-  return '$@' + id.toString(16);
-}
+  var ObjectPrototype = Object.prototype;
+  var knownServerReferences = new WeakMap(); // Serializable values
+  // Thenable<ReactServerValue>
+  // function serializeByValueID(id: number): string {
+  //   return '$' + id.toString(16);
+  // }
+
+  function serializePromiseID(id) {
+    return '$@' + id.toString(16);
+  }
 
-function serializeServerReferenceID(id) {
-  return '$F' + id.toString(16);
-}
+  function serializeServerReferenceID(id) {
+    return '$F' + id.toString(16);
+  }
 
-function serializeSymbolReference(name) {
-  return '$S' + name;
-}
+  function serializeSymbolReference(name) {
+    return '$S' + name;
+  }
 
-function serializeFormDataReference(id) {
-  // Why K? F is "Function". D is "Date". What else?
-  return '$K' + id.toString(16);
-}
+  function serializeFormDataReference(id) {
+    // Why K? F is "Function". D is "Date". What else?
+    return '$K' + id.toString(16);
+  }
 
-function serializeNumber(number) {
-  if (Number.isFinite(number)) {
-    if (number === 0 && 1 / number === -Infinity) {
-      return '$-0';
-    } else {
-      return number;
-    }
-  } else {
-    if (number === Infinity) {
-      return '$Infinity';
-    } else if (number === -Infinity) {
-      return '$-Infinity';
+  function serializeNumber(number) {
+    if (Number.isFinite(number)) {
+      if (number === 0 && 1 / number === -Infinity) {
+        return '$-0';
+      } else {
+        return number;
+      }
     } else {
-      return '$NaN';
+      if (number === Infinity) {
+        return '$Infinity';
+      } else if (number === -Infinity) {
+        return '$-Infinity';
+      } else {
+        return '$NaN';
+      }
     }
   }
-}
 
-function serializeUndefined() {
-  return '$undefined';
-}
-
-function serializeDateFromDateJSON(dateJSON) {
-  // JSON.stringify automatically calls Date.prototype.toJSON which calls toISOString.
-  // We need only tack on a $D prefix.
-  return '$D' + dateJSON;
-}
+  function serializeUndefined() {
+    return '$undefined';
+  }
 
-function serializeBigInt(n) {
-  return '$n' + n.toString(10);
-}
+  function serializeDateFromDateJSON(dateJSON) {
+    // JSON.stringify automatically calls Date.prototype.toJSON which calls toISOString.
+    // We need only tack on a $D prefix.
+    return '$D' + dateJSON;
+  }
 
-function serializeMapID(id) {
-  return '$Q' + id.toString(16);
-}
+  function serializeBigInt(n) {
+    return '$n' + n.toString(10);
+  }
 
-function serializeSetID(id) {
-  return '$W' + id.toString(16);
-}
+  function serializeMapID(id) {
+    return '$Q' + id.toString(16);
+  }
 
-function escapeStringValue(value) {
-  if (value[0] === '$') {
-    // We need to escape $ prefixed strings since we use those to encode
-    // references to IDs and as special symbol values.
-    return '$' + value;
-  } else {
-    return value;
+  function serializeSetID(id) {
+    return '$W' + id.toString(16);
   }
-}
 
-function processReply(root, formFieldPrefix, resolve, reject) {
-  var nextPartId = 1;
-  var pendingParts = 0;
-  var formData = null;
+  function escapeStringValue(value) {
+    if (value[0] === '$') {
+      // We need to escape $ prefixed strings since we use those to encode
+      // references to IDs and as special symbol values.
+      return '$' + value;
+    } else {
+      return value;
+    }
+  }
 
-  function resolveToJSON(key, value) {
-    var parent = this; // Make sure that `parent[key]` wasn't JSONified before `value` was passed to us
+  function processReply(root, formFieldPrefix, resolve, reject) {
+    var nextPartId = 1;
+    var pendingParts = 0;
+    var formData = null;
 
-    {
-      // $FlowFixMe[incompatible-use]
-      var originalValue = parent[key];
+    function resolveToJSON(key, value) {
+      var parent = this; // Make sure that `parent[key]` wasn't JSONified before `value` was passed to us
 
-      if (typeof originalValue === 'object' && originalValue !== value && !(originalValue instanceof Date)) {
-        if (objectName(originalValue) !== 'Object') {
-          error('Only plain objects can be passed to Server Functions from the Client. ' + '%s objects are not supported.%s', objectName(originalValue), describeObjectForErrorMessage(parent, key));
-        } else {
-          error('Only plain objects can be passed to Server Functions from the Client. ' + 'Objects with toJSON methods are not supported. Convert it manually ' + 'to a simple value before passing it to props.%s', describeObjectForErrorMessage(parent, key));
+      {
+        // $FlowFixMe[incompatible-use]
+        var originalValue = parent[key];
+
+        if (
+          typeof originalValue === 'object' &&
+          originalValue !== value &&
+          !(originalValue instanceof Date)
+        ) {
+          if (objectName(originalValue) !== 'Object') {
+            error(
+              'Only plain objects can be passed to Server Functions from the Client. ' +
+                '%s objects are not supported.%s',
+              objectName(originalValue),
+              describeObjectForErrorMessage(parent, key)
+            );
+          } else {
+            error(
+              'Only plain objects can be passed to Server Functions from the Client. ' +
+                'Objects with toJSON methods are not supported. Convert it manually ' +
+                'to a simple value before passing it to props.%s',
+              describeObjectForErrorMessage(parent, key)
+            );
+          }
         }
       }
-    }
-
-    if (value === null) {
-      return null;
-    }
-
-    if (typeof value === 'object') {
-      // $FlowFixMe[method-unbinding]
-      if (typeof value.then === 'function') {
-        // We assume that any object with a .then property is a "Thenable" type,
-        // or a Promise type. Either of which can be represented by a Promise.
-        if (formData === null) {
-          // Upgrade to use FormData to allow us to stream this value.
-          formData = new FormData();
-        }
 
-        pendingParts++;
-        var promiseId = nextPartId++;
-        var thenable = value;
-        thenable.then(function (partValue) {
-          var partJSON = JSON.stringify(partValue, resolveToJSON); // $FlowFixMe[incompatible-type] We know it's not null because we assigned it above.
+      if (value === null) {
+        return null;
+      }
 
-          var data = formData; // eslint-disable-next-line react-internal/safe-string-coercion
+      if (typeof value === 'object') {
+        // $FlowFixMe[method-unbinding]
+        if (typeof value.then === 'function') {
+          // We assume that any object with a .then property is a "Thenable" type,
+          // or a Promise type. Either of which can be represented by a Promise.
+          if (formData === null) {
+            // Upgrade to use FormData to allow us to stream this value.
+            formData = new FormData();
+          }
 
-          data.append(formFieldPrefix + promiseId, partJSON);
-          pendingParts--;
+          pendingParts++;
+          var promiseId = nextPartId++;
+          var thenable = value;
+          thenable.then(
+            function (partValue) {
+              var partJSON = JSON.stringify(partValue, resolveToJSON); // $FlowFixMe[incompatible-type] We know it's not null because we assigned it above.
+
+              var data = formData; // eslint-disable-next-line react-internal/safe-string-coercion
+
+              data.append(formFieldPrefix + promiseId, partJSON);
+              pendingParts--;
+
+              if (pendingParts === 0) {
+                resolve(data);
+              }
+            },
+            function (reason) {
+              // In the future we could consider serializing this as an error
+              // that throws on the server instead.
+              reject(reason);
+            }
+          );
+          return serializePromiseID(promiseId);
+        }
 
-          if (pendingParts === 0) {
-            resolve(data);
+        if (isArray(value)) {
+          // $FlowFixMe[incompatible-return]
+          return value;
+        } // TODO: Should we the Object.prototype.toString.call() to test for cross-realm objects?
+
+        if (value instanceof FormData) {
+          if (formData === null) {
+            // Upgrade to use FormData to allow us to use rich objects as its values.
+            formData = new FormData();
           }
-        }, function (reason) {
-          // In the future we could consider serializing this as an error
-          // that throws on the server instead.
-          reject(reason);
-        });
-        return serializePromiseID(promiseId);
-      }
 
-      if (isArray(value)) {
-        // $FlowFixMe[incompatible-return]
-        return value;
-      } // TODO: Should we the Object.prototype.toString.call() to test for cross-realm objects?
+          var data = formData;
+          var refId = nextPartId++; // Copy all the form fields with a prefix for this reference.
+          // These must come first in the form order because we assume that all the
+          // fields are available before this is referenced.
 
+          var prefix = formFieldPrefix + refId + '_'; // $FlowFixMe[prop-missing]: FormData has forEach.
 
-      if (value instanceof FormData) {
-        if (formData === null) {
-          // Upgrade to use FormData to allow us to use rich objects as its values.
-          formData = new FormData();
+          value.forEach(function (originalValue, originalKey) {
+            data.append(prefix + originalKey, originalValue);
+          });
+          return serializeFormDataReference(refId);
         }
 
-        var data = formData;
-        var refId = nextPartId++; // Copy all the form fields with a prefix for this reference.
-        // These must come first in the form order because we assume that all the
-        // fields are available before this is referenced.
-
-        var prefix = formFieldPrefix + refId + '_'; // $FlowFixMe[prop-missing]: FormData has forEach.
-
-        value.forEach(function (originalValue, originalKey) {
-          data.append(prefix + originalKey, originalValue);
-        });
-        return serializeFormDataReference(refId);
-      }
+        if (value instanceof Map) {
+          var partJSON = JSON.stringify(Array.from(value), resolveToJSON);
 
-      if (value instanceof Map) {
-        var partJSON = JSON.stringify(Array.from(value), resolveToJSON);
+          if (formData === null) {
+            formData = new FormData();
+          }
 
-        if (formData === null) {
-          formData = new FormData();
+          var mapId = nextPartId++;
+          formData.append(formFieldPrefix + mapId, partJSON);
+          return serializeMapID(mapId);
         }
 
-        var mapId = nextPartId++;
-        formData.append(formFieldPrefix + mapId, partJSON);
-        return serializeMapID(mapId);
-      }
+        if (value instanceof Set) {
+          var _partJSON = JSON.stringify(Array.from(value), resolveToJSON);
 
-      if (value instanceof Set) {
-        var _partJSON = JSON.stringify(Array.from(value), resolveToJSON);
+          if (formData === null) {
+            formData = new FormData();
+          }
 
-        if (formData === null) {
-          formData = new FormData();
+          var setId = nextPartId++;
+          formData.append(formFieldPrefix + setId, _partJSON);
+          return serializeSetID(setId);
         }
 
-        var setId = nextPartId++;
-        formData.append(formFieldPrefix + setId, _partJSON);
-        return serializeSetID(setId);
-      }
+        var iteratorFn = getIteratorFn(value);
 
-      var iteratorFn = getIteratorFn(value);
+        if (iteratorFn) {
+          return Array.from(value);
+        } // Verify that this is a simple plain object.
 
-      if (iteratorFn) {
-        return Array.from(value);
-      } // Verify that this is a simple plain object.
+        var proto = getPrototypeOf(value);
 
+        if (proto !== ObjectPrototype && (proto === null || getPrototypeOf(proto) !== null)) {
+          throw new Error(
+            'Only plain objects, and a few built-ins, can be passed to Server Actions. ' +
+              'Classes or null prototypes are not supported.'
+          );
+        }
 
-      var proto = getPrototypeOf(value);
+        {
+          if (value.$$typeof === REACT_ELEMENT_TYPE) {
+            error(
+              'React Element cannot be passed to Server Functions from the Client.%s',
+              describeObjectForErrorMessage(parent, key)
+            );
+          } else if (value.$$typeof === REACT_LAZY_TYPE) {
+            error(
+              'React Lazy cannot be passed to Server Functions from the Client.%s',
+              describeObjectForErrorMessage(parent, key)
+            );
+          } else if (value.$$typeof === REACT_PROVIDER_TYPE) {
+            error(
+              'React Context Providers cannot be passed to Server Functions from the Client.%s',
+              describeObjectForErrorMessage(parent, key)
+            );
+          } else if (objectName(value) !== 'Object') {
+            error(
+              'Only plain objects can be passed to Server Functions from the Client. ' +
+                '%s objects are not supported.%s',
+              objectName(value),
+              describeObjectForErrorMessage(parent, key)
+            );
+          } else if (!isSimpleObject(value)) {
+            error(
+              'Only plain objects can be passed to Server Functions from the Client. ' +
+                'Classes or other objects with methods are not supported.%s',
+              describeObjectForErrorMessage(parent, key)
+            );
+          } else if (Object.getOwnPropertySymbols) {
+            var symbols = Object.getOwnPropertySymbols(value);
+
+            if (symbols.length > 0) {
+              error(
+                'Only plain objects can be passed to Server Functions from the Client. ' +
+                  'Objects with symbol properties like %s are not supported.%s',
+                symbols[0].description,
+                describeObjectForErrorMessage(parent, key)
+              );
+            }
+          }
+        } // $FlowFixMe[incompatible-return]
 
-      if (proto !== ObjectPrototype && (proto === null || getPrototypeOf(proto) !== null)) {
-        throw new Error('Only plain objects, and a few built-ins, can be passed to Server Actions. ' + 'Classes or null prototypes are not supported.');
+        return value;
       }
 
-      {
-        if (value.$$typeof === REACT_ELEMENT_TYPE) {
-          error('React Element cannot be passed to Server Functions from the Client.%s', describeObjectForErrorMessage(parent, key));
-        } else if (value.$$typeof === REACT_LAZY_TYPE) {
-          error('React Lazy cannot be passed to Server Functions from the Client.%s', describeObjectForErrorMessage(parent, key));
-        } else if (value.$$typeof === REACT_PROVIDER_TYPE) {
-          error('React Context Providers cannot be passed to Server Functions from the Client.%s', describeObjectForErrorMessage(parent, key));
-        } else if (objectName(value) !== 'Object') {
-          error('Only plain objects can be passed to Server Functions from the Client. ' + '%s objects are not supported.%s', objectName(value), describeObjectForErrorMessage(parent, key));
-        } else if (!isSimpleObject(value)) {
-          error('Only plain objects can be passed to Server Functions from the Client. ' + 'Classes or other objects with methods are not supported.%s', describeObjectForErrorMessage(parent, key));
-        } else if (Object.getOwnPropertySymbols) {
-          var symbols = Object.getOwnPropertySymbols(value);
-
-          if (symbols.length > 0) {
-            error('Only plain objects can be passed to Server Functions from the Client. ' + 'Objects with symbol properties like %s are not supported.%s', symbols[0].description, describeObjectForErrorMessage(parent, key));
+      if (typeof value === 'string') {
+        // TODO: Maybe too clever. If we support URL there's no similar trick.
+        if (value[value.length - 1] === 'Z') {
+          // Possibly a Date, whose toJSON automatically calls toISOString
+          // $FlowFixMe[incompatible-use]
+          var _originalValue = parent[key];
+
+          if (_originalValue instanceof Date) {
+            return serializeDateFromDateJSON(value);
           }
         }
-      } // $FlowFixMe[incompatible-return]
 
-
-      return value;
-    }
-
-    if (typeof value === 'string') {
-      // TODO: Maybe too clever. If we support URL there's no similar trick.
-      if (value[value.length - 1] === 'Z') {
-        // Possibly a Date, whose toJSON automatically calls toISOString
-        // $FlowFixMe[incompatible-use]
-        var _originalValue = parent[key];
-
-        if (_originalValue instanceof Date) {
-          return serializeDateFromDateJSON(value);
-        }
+        return escapeStringValue(value);
       }
 
-      return escapeStringValue(value);
-    }
-
-    if (typeof value === 'boolean') {
-      return value;
-    }
-
-    if (typeof value === 'number') {
-      return serializeNumber(value);
-    }
+      if (typeof value === 'boolean') {
+        return value;
+      }
 
-    if (typeof value === 'undefined') {
-      return serializeUndefined();
-    }
+      if (typeof value === 'number') {
+        return serializeNumber(value);
+      }
 
-    if (typeof value === 'function') {
-      var metaData = knownServerReferences.get(value);
+      if (typeof value === 'undefined') {
+        return serializeUndefined();
+      }
 
-      if (metaData !== undefined) {
-        var metaDataJSON = JSON.stringify(metaData, resolveToJSON);
+      if (typeof value === 'function') {
+        var metaData = knownServerReferences.get(value);
 
-        if (formData === null) {
-          // Upgrade to use FormData to allow us to stream this value.
-          formData = new FormData();
-        } // The reference to this function came from the same client so we can pass it back.
+        if (metaData !== undefined) {
+          var metaDataJSON = JSON.stringify(metaData, resolveToJSON);
 
+          if (formData === null) {
+            // Upgrade to use FormData to allow us to stream this value.
+            formData = new FormData();
+          } // The reference to this function came from the same client so we can pass it back.
 
-        var _refId = nextPartId++; // eslint-disable-next-line react-internal/safe-string-coercion
+          var _refId = nextPartId++; // eslint-disable-next-line react-internal/safe-string-coercion
 
+          formData.set(formFieldPrefix + _refId, metaDataJSON);
+          return serializeServerReferenceID(_refId);
+        }
 
-        formData.set(formFieldPrefix + _refId, metaDataJSON);
-        return serializeServerReferenceID(_refId);
+        throw new Error(
+          'Client Functions cannot be passed directly to Server Functions. ' +
+            'Only Functions passed from the Server can be passed back again.'
+        );
       }
 
-      throw new Error('Client Functions cannot be passed directly to Server Functions. ' + 'Only Functions passed from the Server can be passed back again.');
-    }
+      if (typeof value === 'symbol') {
+        // $FlowFixMe[incompatible-type] `description` might be undefined
+        var name = value.description;
+
+        if (Symbol.for(name) !== value) {
+          throw new Error(
+            'Only global symbols received from Symbol.for(...) can be passed to Server Functions. ' +
+              ('The symbol Symbol.for(' + // $FlowFixMe[incompatible-type] `description` might be undefined
+                value.description +
+                ') cannot be found among global symbols.')
+          );
+        }
 
-    if (typeof value === 'symbol') {
-      // $FlowFixMe[incompatible-type] `description` might be undefined
-      var name = value.description;
+        return serializeSymbolReference(name);
+      }
 
-      if (Symbol.for(name) !== value) {
-        throw new Error('Only global symbols received from Symbol.for(...) can be passed to Server Functions. ' + ("The symbol Symbol.for(" + // $FlowFixMe[incompatible-type] `description` might be undefined
-        value.description + ") cannot be found among global symbols."));
+      if (typeof value === 'bigint') {
+        return serializeBigInt(value);
       }
 
-      return serializeSymbolReference(name);
-    }
+      throw new Error(
+        'Type ' + typeof value + ' is not supported as an argument to a Server Function.'
+      );
+    } // $FlowFixMe[incompatible-type] it's not going to be undefined because we'll encode it.
 
-    if (typeof value === 'bigint') {
-      return serializeBigInt(value);
-    }
+    var json = JSON.stringify(root, resolveToJSON);
 
-    throw new Error("Type " + typeof value + " is not supported as an argument to a Server Function.");
-  } // $FlowFixMe[incompatible-type] it's not going to be undefined because we'll encode it.
+    if (formData === null) {
+      // If it's a simple data structure, we just use plain JSON.
+      resolve(json);
+    } else {
+      // Otherwise, we use FormData to let us stream in the result.
+      formData.set(formFieldPrefix + '0', json);
 
+      if (pendingParts === 0) {
+        // $FlowFixMe[incompatible-call] this has already been refined.
+        resolve(formData);
+      }
+    }
+  }
 
-  var json = JSON.stringify(root, resolveToJSON);
+  function registerServerReference(proxy, reference) {
+    knownServerReferences.set(proxy, reference);
+  } // $FlowFixMe[method-unbinding]
 
-  if (formData === null) {
-    // If it's a simple data structure, we just use plain JSON.
-    resolve(json);
-  } else {
-    // Otherwise, we use FormData to let us stream in the result.
-    formData.set(formFieldPrefix + '0', json);
+  function createServerReference(id, callServer) {
+    var proxy = function () {
+      // $FlowFixMe[method-unbinding]
+      var args = Array.prototype.slice.call(arguments);
+      return callServer(id, args);
+    };
 
-    if (pendingParts === 0) {
-      // $FlowFixMe[incompatible-call] this has already been refined.
-      resolve(formData);
-    }
+    registerServerReference(proxy, {
+      id: id,
+      bound: null,
+    });
+    return proxy;
   }
-}
 
-function registerServerReference(proxy, reference) {
+  var ContextRegistry = ReactSharedInternals.ContextRegistry;
+  function getOrCreateServerContext(globalName) {
+    if (!ContextRegistry[globalName]) {
+      var context = {
+        $$typeof: REACT_SERVER_CONTEXT_TYPE,
+        // As a workaround to support multiple concurrent renderers, we categorize
+        // some renderers as primary and others as secondary. We only expect
+        // there to be two concurrent renderers at most: React Native (primary) and
+        // Fabric (secondary); React DOM (primary) and React ART (secondary).
+        // Secondary renderers store their context values on separate fields.
+        _currentValue: REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED,
+        _currentValue2: REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED,
+        _defaultValue: REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED,
+        // Used to track how many concurrent renderers this context currently
+        // supports within in a single renderer. Such as parallel server rendering.
+        _threadCount: 0,
+        // These are circular
+        Provider: null,
+        Consumer: null,
+        _globalName: globalName,
+      };
+      context.Provider = {
+        $$typeof: REACT_PROVIDER_TYPE,
+        _context: context,
+      };
 
-  knownServerReferences.set(proxy, reference);
-} // $FlowFixMe[method-unbinding]
+      {
+        var hasWarnedAboutUsingConsumer;
+        context._currentRenderer = null;
+        context._currentRenderer2 = null;
+        Object.defineProperties(context, {
+          Consumer: {
+            get: function () {
+              if (!hasWarnedAboutUsingConsumer) {
+                error('Consumer pattern is not supported by ReactServerContext');
+
+                hasWarnedAboutUsingConsumer = true;
+              }
 
-function createServerReference(id, callServer) {
-  var proxy = function () {
-    // $FlowFixMe[method-unbinding]
-    var args = Array.prototype.slice.call(arguments);
-    return callServer(id, args);
-  };
+              return null;
+            },
+          },
+        });
+      }
 
-  registerServerReference(proxy, {
-    id: id,
-    bound: null
-  });
-  return proxy;
-}
-
-var ContextRegistry = ReactSharedInternals.ContextRegistry;
-function getOrCreateServerContext(globalName) {
-  if (!ContextRegistry[globalName]) {
-    var context = {
-      $$typeof: REACT_SERVER_CONTEXT_TYPE,
-      // As a workaround to support multiple concurrent renderers, we categorize
-      // some renderers as primary and others as secondary. We only expect
-      // there to be two concurrent renderers at most: React Native (primary) and
-      // Fabric (secondary); React DOM (primary) and React ART (secondary).
-      // Secondary renderers store their context values on separate fields.
-      _currentValue: REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED,
-      _currentValue2: REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED,
-      _defaultValue: REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED,
-      // Used to track how many concurrent renderers this context currently
-      // supports within in a single renderer. Such as parallel server rendering.
-      _threadCount: 0,
-      // These are circular
-      Provider: null,
-      Consumer: null,
-      _globalName: globalName
-    };
-    context.Provider = {
-      $$typeof: REACT_PROVIDER_TYPE,
-      _context: context
-    };
+      ContextRegistry[globalName] = context;
+    }
 
-    {
-      var hasWarnedAboutUsingConsumer;
-      context._currentRenderer = null;
-      context._currentRenderer2 = null;
-      Object.defineProperties(context, {
-        Consumer: {
-          get: function () {
-            if (!hasWarnedAboutUsingConsumer) {
-              error('Consumer pattern is not supported by ReactServerContext');
-
-              hasWarnedAboutUsingConsumer = true;
-            }
+    return ContextRegistry[globalName];
+  }
 
-            return null;
+  var ROW_ID = 0;
+  var ROW_TAG = 1;
+  var ROW_LENGTH = 2;
+  var ROW_CHUNK_BY_NEWLINE = 3;
+  var ROW_CHUNK_BY_LENGTH = 4;
+  var PENDING = 'pending';
+  var BLOCKED = 'blocked';
+  var CYCLIC = 'cyclic';
+  var RESOLVED_MODEL = 'resolved_model';
+  var RESOLVED_MODULE = 'resolved_module';
+  var INITIALIZED = 'fulfilled';
+  var ERRORED = 'rejected'; // $FlowFixMe[missing-this-annot]
+
+  function Chunk(status, value, reason, response) {
+    this.status = status;
+    this.value = value;
+    this.reason = reason;
+    this._response = response;
+  } // We subclass Promise.prototype so that we get other methods like .catch
+
+  Chunk.prototype = Object.create(Promise.prototype); // TODO: This doesn't return a new Promise chain unlike the real .then
+
+  Chunk.prototype.then = function (resolve, reject) {
+    var chunk = this; // If we have resolved content, we try to initialize it first which
+    // might put us back into one of the other states.
+
+    switch (chunk.status) {
+      case RESOLVED_MODEL:
+        initializeModelChunk(chunk);
+        break;
+
+      case RESOLVED_MODULE:
+        initializeModuleChunk(chunk);
+        break;
+    } // The status might have changed after initialization.
+
+    switch (chunk.status) {
+      case INITIALIZED:
+        resolve(chunk.value);
+        break;
+
+      case PENDING:
+      case BLOCKED:
+      case CYCLIC:
+        if (resolve) {
+          if (chunk.value === null) {
+            chunk.value = [];
           }
-        }
-      });
-    }
 
-    ContextRegistry[globalName] = context;
-  }
-
-  return ContextRegistry[globalName];
-}
-
-var ROW_ID = 0;
-var ROW_TAG = 1;
-var ROW_LENGTH = 2;
-var ROW_CHUNK_BY_NEWLINE = 3;
-var ROW_CHUNK_BY_LENGTH = 4;
-var PENDING = 'pending';
-var BLOCKED = 'blocked';
-var CYCLIC = 'cyclic';
-var RESOLVED_MODEL = 'resolved_model';
-var RESOLVED_MODULE = 'resolved_module';
-var INITIALIZED = 'fulfilled';
-var ERRORED = 'rejected'; // $FlowFixMe[missing-this-annot]
-
-function Chunk(status, value, reason, response) {
-  this.status = status;
-  this.value = value;
-  this.reason = reason;
-  this._response = response;
-} // We subclass Promise.prototype so that we get other methods like .catch
-
-
-Chunk.prototype = Object.create(Promise.prototype); // TODO: This doesn't return a new Promise chain unlike the real .then
-
-Chunk.prototype.then = function (resolve, reject) {
-  var chunk = this; // If we have resolved content, we try to initialize it first which
-  // might put us back into one of the other states.
-
-  switch (chunk.status) {
-    case RESOLVED_MODEL:
-      initializeModelChunk(chunk);
-      break;
-
-    case RESOLVED_MODULE:
-      initializeModuleChunk(chunk);
-      break;
-  } // The status might have changed after initialization.
-
-
-  switch (chunk.status) {
-    case INITIALIZED:
-      resolve(chunk.value);
-      break;
-
-    case PENDING:
-    case BLOCKED:
-    case CYCLIC:
-      if (resolve) {
-        if (chunk.value === null) {
-          chunk.value = [];
+          chunk.value.push(resolve);
         }
 
-        chunk.value.push(resolve);
-      }
+        if (reject) {
+          if (chunk.reason === null) {
+            chunk.reason = [];
+          }
 
-      if (reject) {
-        if (chunk.reason === null) {
-          chunk.reason = [];
+          chunk.reason.push(reject);
         }
 
-        chunk.reason.push(reject);
-      }
+        break;
 
-      break;
-
-    default:
-      reject(chunk.reason);
-      break;
-  }
-};
-
-function readChunk(chunk) {
-  // If we have resolved content, we try to initialize it first which
-  // might put us back into one of the other states.
-  switch (chunk.status) {
-    case RESOLVED_MODEL:
-      initializeModelChunk(chunk);
-      break;
-
-    case RESOLVED_MODULE:
-      initializeModuleChunk(chunk);
-      break;
-  } // The status might have changed after initialization.
-
-
-  switch (chunk.status) {
-    case INITIALIZED:
-      return chunk.value;
-
-    case PENDING:
-    case BLOCKED:
-    case CYCLIC:
-      // eslint-disable-next-line no-throw-literal
-      throw chunk;
-
-    default:
-      throw chunk.reason;
-  }
-}
-
-function getRoot(response) {
-  var chunk = getChunk(response, 0);
-  return chunk;
-}
-
-function createPendingChunk(response) {
-  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
-  return new Chunk(PENDING, null, null, response);
-}
-
-function createBlockedChunk(response) {
-  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
-  return new Chunk(BLOCKED, null, null, response);
-}
-
-function createErrorChunk(response, error) {
-  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
-  return new Chunk(ERRORED, null, error, response);
-}
-
-function wakeChunk(listeners, value) {
-  for (var i = 0; i < listeners.length; i++) {
-    var listener = listeners[i];
-    listener(value);
-  }
-}
-
-function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
-  switch (chunk.status) {
-    case INITIALIZED:
-      wakeChunk(resolveListeners, chunk.value);
-      break;
-
-    case PENDING:
-    case BLOCKED:
-    case CYCLIC:
-      chunk.value = resolveListeners;
-      chunk.reason = rejectListeners;
-      break;
-
-    case ERRORED:
-      if (rejectListeners) {
-        wakeChunk(rejectListeners, chunk.reason);
-      }
+      default:
+        reject(chunk.reason);
+        break;
+    }
+  };
+
+  function readChunk(chunk) {
+    // If we have resolved content, we try to initialize it first which
+    // might put us back into one of the other states.
+    switch (chunk.status) {
+      case RESOLVED_MODEL:
+        initializeModelChunk(chunk);
+        break;
+
+      case RESOLVED_MODULE:
+        initializeModuleChunk(chunk);
+        break;
+    } // The status might have changed after initialization.
+
+    switch (chunk.status) {
+      case INITIALIZED:
+        return chunk.value;
+
+      case PENDING:
+      case BLOCKED:
+      case CYCLIC:
+        // eslint-disable-next-line no-throw-literal
+        throw chunk;
 
-      break;
+      default:
+        throw chunk.reason;
+    }
   }
-}
 
-function triggerErrorOnChunk(chunk, error) {
-  if (chunk.status !== PENDING && chunk.status !== BLOCKED) {
-    // We already resolved. We didn't expect to see this.
-    return;
+  function getRoot(response) {
+    var chunk = getChunk(response, 0);
+    return chunk;
   }
 
-  var listeners = chunk.reason;
-  var erroredChunk = chunk;
-  erroredChunk.status = ERRORED;
-  erroredChunk.reason = error;
+  function createPendingChunk(response) {
+    // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+    return new Chunk(PENDING, null, null, response);
+  }
 
-  if (listeners !== null) {
-    wakeChunk(listeners, error);
+  function createBlockedChunk(response) {
+    // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+    return new Chunk(BLOCKED, null, null, response);
   }
-}
 
-function createResolvedModelChunk(response, value) {
-  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
-  return new Chunk(RESOLVED_MODEL, value, null, response);
-}
+  function createErrorChunk(response, error) {
+    // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+    return new Chunk(ERRORED, null, error, response);
+  }
 
-function createResolvedModuleChunk(response, value) {
-  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
-  return new Chunk(RESOLVED_MODULE, value, null, response);
-}
+  function wakeChunk(listeners, value) {
+    for (var i = 0; i < listeners.length; i++) {
+      var listener = listeners[i];
+      listener(value);
+    }
+  }
 
-function createInitializedTextChunk(response, value) {
-  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
-  return new Chunk(INITIALIZED, value, null, response);
-}
+  function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
+    switch (chunk.status) {
+      case INITIALIZED:
+        wakeChunk(resolveListeners, chunk.value);
+        break;
+
+      case PENDING:
+      case BLOCKED:
+      case CYCLIC:
+        chunk.value = resolveListeners;
+        chunk.reason = rejectListeners;
+        break;
+
+      case ERRORED:
+        if (rejectListeners) {
+          wakeChunk(rejectListeners, chunk.reason);
+        }
 
-function resolveModelChunk(chunk, value) {
-  if (chunk.status !== PENDING) {
-    // We already resolved. We didn't expect to see this.
-    return;
+        break;
+    }
   }
 
-  var resolveListeners = chunk.value;
-  var rejectListeners = chunk.reason;
-  var resolvedChunk = chunk;
-  resolvedChunk.status = RESOLVED_MODEL;
-  resolvedChunk.value = value;
+  function triggerErrorOnChunk(chunk, error) {
+    if (chunk.status !== PENDING && chunk.status !== BLOCKED) {
+      // We already resolved. We didn't expect to see this.
+      return;
+    }
 
-  if (resolveListeners !== null) {
-    // This is unfortunate that we're reading this eagerly if
-    // we already have listeners attached since they might no
-    // longer be rendered or might not be the highest pri.
-    initializeModelChunk(resolvedChunk); // The status might have changed after initialization.
+    var listeners = chunk.reason;
+    var erroredChunk = chunk;
+    erroredChunk.status = ERRORED;
+    erroredChunk.reason = error;
 
-    wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
+    if (listeners !== null) {
+      wakeChunk(listeners, error);
+    }
   }
-}
 
-function resolveModuleChunk(chunk, value) {
-  if (chunk.status !== PENDING && chunk.status !== BLOCKED) {
-    // We already resolved. We didn't expect to see this.
-    return;
+  function createResolvedModelChunk(response, value) {
+    // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+    return new Chunk(RESOLVED_MODEL, value, null, response);
   }
 
-  var resolveListeners = chunk.value;
-  var rejectListeners = chunk.reason;
-  var resolvedChunk = chunk;
-  resolvedChunk.status = RESOLVED_MODULE;
-  resolvedChunk.value = value;
+  function createResolvedModuleChunk(response, value) {
+    // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+    return new Chunk(RESOLVED_MODULE, value, null, response);
+  }
 
-  if (resolveListeners !== null) {
-    initializeModuleChunk(resolvedChunk);
-    wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
+  function createInitializedTextChunk(response, value) {
+    // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+    return new Chunk(INITIALIZED, value, null, response);
   }
-}
 
-var initializingChunk = null;
-var initializingChunkBlockedModel = null;
+  function resolveModelChunk(chunk, value) {
+    if (chunk.status !== PENDING) {
+      // We already resolved. We didn't expect to see this.
+      return;
+    }
 
-function initializeModelChunk(chunk) {
-  var prevChunk = initializingChunk;
-  var prevBlocked = initializingChunkBlockedModel;
-  initializingChunk = chunk;
-  initializingChunkBlockedModel = null;
-  var resolvedModel = chunk.value; // We go to the CYCLIC state until we've fully resolved this.
-  // We do this before parsing in case we try to initialize the same chunk
-  // while parsing the model. Such as in a cyclic reference.
+    var resolveListeners = chunk.value;
+    var rejectListeners = chunk.reason;
+    var resolvedChunk = chunk;
+    resolvedChunk.status = RESOLVED_MODEL;
+    resolvedChunk.value = value;
 
-  var cyclicChunk = chunk;
-  cyclicChunk.status = CYCLIC;
-  cyclicChunk.value = null;
-  cyclicChunk.reason = null;
+    if (resolveListeners !== null) {
+      // This is unfortunate that we're reading this eagerly if
+      // we already have listeners attached since they might no
+      // longer be rendered or might not be the highest pri.
+      initializeModelChunk(resolvedChunk); // The status might have changed after initialization.
 
-  try {
-    var value = parseModel(chunk._response, resolvedModel);
+      wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
+    }
+  }
 
-    if (initializingChunkBlockedModel !== null && initializingChunkBlockedModel.deps > 0) {
-      initializingChunkBlockedModel.value = value; // We discovered new dependencies on modules that are not yet resolved.
-      // We have to go the BLOCKED state until they're resolved.
+  function resolveModuleChunk(chunk, value) {
+    if (chunk.status !== PENDING && chunk.status !== BLOCKED) {
+      // We already resolved. We didn't expect to see this.
+      return;
+    }
 
-      var blockedChunk = chunk;
-      blockedChunk.status = BLOCKED;
-      blockedChunk.value = null;
-      blockedChunk.reason = null;
-    } else {
-      var resolveListeners = cyclicChunk.value;
-      var initializedChunk = chunk;
-      initializedChunk.status = INITIALIZED;
-      initializedChunk.value = value;
+    var resolveListeners = chunk.value;
+    var rejectListeners = chunk.reason;
+    var resolvedChunk = chunk;
+    resolvedChunk.status = RESOLVED_MODULE;
+    resolvedChunk.value = value;
 
-      if (resolveListeners !== null) {
-        wakeChunk(resolveListeners, value);
-      }
+    if (resolveListeners !== null) {
+      initializeModuleChunk(resolvedChunk);
+      wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
     }
-  } catch (error) {
-    var erroredChunk = chunk;
-    erroredChunk.status = ERRORED;
-    erroredChunk.reason = error;
-  } finally {
-    initializingChunk = prevChunk;
-    initializingChunkBlockedModel = prevBlocked;
-  }
-}
-
-function initializeModuleChunk(chunk) {
-  try {
-    var value = requireModule(chunk.value);
-    var initializedChunk = chunk;
-    initializedChunk.status = INITIALIZED;
-    initializedChunk.value = value;
-  } catch (error) {
-    var erroredChunk = chunk;
-    erroredChunk.status = ERRORED;
-    erroredChunk.reason = error;
   }
-} // Report that any missing chunks in the model is now going to throw this
-// error upon read. Also notify any pending promises.
 
-
-function reportGlobalError(response, error) {
-  response._chunks.forEach(function (chunk) {
-    // If this chunk was already resolved or errored, it won't
-    // trigger an error but if it wasn't then we need to
-    // because we won't be getting any new data to resolve it.
-    if (chunk.status === PENDING) {
-      triggerErrorOnChunk(chunk, error);
+  var initializingChunk = null;
+  var initializingChunkBlockedModel = null;
+
+  function initializeModelChunk(chunk) {
+    var prevChunk = initializingChunk;
+    var prevBlocked = initializingChunkBlockedModel;
+    initializingChunk = chunk;
+    initializingChunkBlockedModel = null;
+    var resolvedModel = chunk.value; // We go to the CYCLIC state until we've fully resolved this.
+    // We do this before parsing in case we try to initialize the same chunk
+    // while parsing the model. Such as in a cyclic reference.
+
+    var cyclicChunk = chunk;
+    cyclicChunk.status = CYCLIC;
+    cyclicChunk.value = null;
+    cyclicChunk.reason = null;
+
+    try {
+      var value = parseModel(chunk._response, resolvedModel);
+
+      if (initializingChunkBlockedModel !== null && initializingChunkBlockedModel.deps > 0) {
+        initializingChunkBlockedModel.value = value; // We discovered new dependencies on modules that are not yet resolved.
+        // We have to go the BLOCKED state until they're resolved.
+
+        var blockedChunk = chunk;
+        blockedChunk.status = BLOCKED;
+        blockedChunk.value = null;
+        blockedChunk.reason = null;
+      } else {
+        var resolveListeners = cyclicChunk.value;
+        var initializedChunk = chunk;
+        initializedChunk.status = INITIALIZED;
+        initializedChunk.value = value;
+
+        if (resolveListeners !== null) {
+          wakeChunk(resolveListeners, value);
+        }
+      }
+    } catch (error) {
+      var erroredChunk = chunk;
+      erroredChunk.status = ERRORED;
+      erroredChunk.reason = error;
+    } finally {
+      initializingChunk = prevChunk;
+      initializingChunkBlockedModel = prevBlocked;
     }
-  });
-}
-
-function createElement(type, key, props) {
-  var element = {
-    // This tag allows us to uniquely identify this as a React Element
-    $$typeof: REACT_ELEMENT_TYPE,
-    // Built-in properties that belong on the element
-    type: type,
-    key: key,
-    ref: null,
-    props: props,
-    // Record the component responsible for creating this element.
-    _owner: null
-  };
-
-  {
-    // We don't really need to add any of these but keeping them for good measure.
-    // Unfortunately, _store is enumerable in jest matchers so for equality to
-    // work, I need to keep it or make _store non-enumerable in the other file.
-    element._store = {};
-    Object.defineProperty(element._store, 'validated', {
-      configurable: false,
-      enumerable: false,
-      writable: true,
-      value: true // This element has already been validated on the server.
+  }
 
-    });
-    Object.defineProperty(element, '_self', {
-      configurable: false,
-      enumerable: false,
-      writable: false,
-      value: null
-    });
-    Object.defineProperty(element, '_source', {
-      configurable: false,
-      enumerable: false,
-      writable: false,
-      value: null
+  function initializeModuleChunk(chunk) {
+    try {
+      var value = requireModule(chunk.value);
+      var initializedChunk = chunk;
+      initializedChunk.status = INITIALIZED;
+      initializedChunk.value = value;
+    } catch (error) {
+      var erroredChunk = chunk;
+      erroredChunk.status = ERRORED;
+      erroredChunk.reason = error;
+    }
+  } // Report that any missing chunks in the model is now going to throw this
+  // error upon read. Also notify any pending promises.
+
+  function reportGlobalError(response, error) {
+    response._chunks.forEach(function (chunk) {
+      // If this chunk was already resolved or errored, it won't
+      // trigger an error but if it wasn't then we need to
+      // because we won't be getting any new data to resolve it.
+      if (chunk.status === PENDING) {
+        console.log('ERROR>ON>CHUNK:', chunk);
+        triggerErrorOnChunk(chunk, error);
+      }
     });
   }
 
-  return element;
-}
-
-function createLazyChunkWrapper(chunk) {
-  var lazyType = {
-    $$typeof: REACT_LAZY_TYPE,
-    _payload: chunk,
-    _init: readChunk
-  };
-  return lazyType;
-}
+  function createElement(type, key, props) {
+    var element = {
+      // This tag allows us to uniquely identify this as a React Element
+      $$typeof: REACT_ELEMENT_TYPE,
+      // Built-in properties that belong on the element
+      type: type,
+      key: key,
+      ref: null,
+      props: props,
+      // Record the component responsible for creating this element.
+      _owner: null,
+    };
 
-function getChunk(response, id) {
-  var chunks = response._chunks;
-  var chunk = chunks.get(id);
+    {
+      // We don't really need to add any of these but keeping them for good measure.
+      // Unfortunately, _store is enumerable in jest matchers so for equality to
+      // work, I need to keep it or make _store non-enumerable in the other file.
+      element._store = {};
+      Object.defineProperty(element._store, 'validated', {
+        configurable: false,
+        enumerable: false,
+        writable: true,
+        value: true, // This element has already been validated on the server.
+      });
+      Object.defineProperty(element, '_self', {
+        configurable: false,
+        enumerable: false,
+        writable: false,
+        value: null,
+      });
+      Object.defineProperty(element, '_source', {
+        configurable: false,
+        enumerable: false,
+        writable: false,
+        value: null,
+      });
+    }
 
-  if (!chunk) {
-    chunk = createPendingChunk(response);
-    chunks.set(id, chunk);
+    return element;
   }
 
-  return chunk;
-}
-
-function createModelResolver(chunk, parentObject, key, cyclic) {
-  var blocked;
+  function createLazyChunkWrapper(chunk) {
+    var lazyType = {
+      $$typeof: REACT_LAZY_TYPE,
+      _payload: chunk,
+      _init: readChunk,
+    };
+    return lazyType;
+  }
 
-  if (initializingChunkBlockedModel) {
-    blocked = initializingChunkBlockedModel;
+  function getChunk(response, id) {
+    var chunks = response._chunks;
+    var chunk = chunks.get(id);
 
-    if (!cyclic) {
-      blocked.deps++;
+    if (!chunk) {
+      chunk = createPendingChunk(response);
+      chunks.set(id, chunk);
     }
-  } else {
-    blocked = initializingChunkBlockedModel = {
-      deps: cyclic ? 0 : 1,
-      value: null
-    };
-  }
 
-  return function (value) {
-    parentObject[key] = value;
-    blocked.deps--;
+    return chunk;
+  }
 
-    if (blocked.deps === 0) {
-      if (chunk.status !== BLOCKED) {
-        return;
-      }
+  function createModelResolver(chunk, parentObject, key, cyclic) {
+    var blocked;
 
-      var resolveListeners = chunk.value;
-      var initializedChunk = chunk;
-      initializedChunk.status = INITIALIZED;
-      initializedChunk.value = blocked.value;
+    if (initializingChunkBlockedModel) {
+      blocked = initializingChunkBlockedModel;
 
-      if (resolveListeners !== null) {
-        wakeChunk(resolveListeners, blocked.value);
+      if (!cyclic) {
+        blocked.deps++;
       }
+    } else {
+      blocked = initializingChunkBlockedModel = {
+        deps: cyclic ? 0 : 1,
+        value: null,
+      };
     }
-  };
-}
 
-function createModelReject(chunk) {
-  return function (error) {
-    return triggerErrorOnChunk(chunk, error);
-  };
-}
+    return function (value) {
+      parentObject[key] = value;
+      blocked.deps--;
 
-function createServerReferenceProxy(response, metaData) {
-  var callServer = response._callServer;
+      if (blocked.deps === 0) {
+        if (chunk.status !== BLOCKED) {
+          return;
+        }
 
-  var proxy = function () {
-    // $FlowFixMe[method-unbinding]
-    var args = Array.prototype.slice.call(arguments);
-    var p = metaData.bound;
+        var resolveListeners = chunk.value;
+        var initializedChunk = chunk;
+        initializedChunk.status = INITIALIZED;
+        initializedChunk.value = blocked.value;
 
-    if (!p) {
-      return callServer(metaData.id, args);
-    }
+        if (resolveListeners !== null) {
+          wakeChunk(resolveListeners, blocked.value);
+        }
+      }
+    };
+  }
 
-    if (p.status === INITIALIZED) {
-      var bound = p.value;
-      return callServer(metaData.id, bound.concat(args));
-    } // Since this is a fake Promise whose .then doesn't chain, we have to wrap it.
-    // TODO: Remove the wrapper once that's fixed.
+  function createModelReject(chunk) {
+    return function (error) {
+      return triggerErrorOnChunk(chunk, error);
+    };
+  }
 
+  function createServerReferenceProxy(response, metaData) {
+    var callServer = response._callServer;
 
-    return Promise.resolve(p).then(function (bound) {
-      return callServer(metaData.id, bound.concat(args));
-    });
-  };
+    var proxy = function () {
+      // $FlowFixMe[method-unbinding]
+      var args = Array.prototype.slice.call(arguments);
+      var p = metaData.bound;
 
-  registerServerReference(proxy, metaData);
-  return proxy;
-}
+      if (!p) {
+        return callServer(metaData.id, args);
+      }
 
-function getOutlinedModel(response, id) {
-  var chunk = getChunk(response, id);
+      if (p.status === INITIALIZED) {
+        var bound = p.value;
+        return callServer(metaData.id, bound.concat(args));
+      } // Since this is a fake Promise whose .then doesn't chain, we have to wrap it.
+      // TODO: Remove the wrapper once that's fixed.
 
-  switch (chunk.status) {
-    case RESOLVED_MODEL:
-      initializeModelChunk(chunk);
-      break;
-  } // The status might have changed after initialization.
+      return Promise.resolve(p).then(function (bound) {
+        return callServer(metaData.id, bound.concat(args));
+      });
+    };
 
+    registerServerReference(proxy, metaData);
+    return proxy;
+  }
 
-  switch (chunk.status) {
-    case INITIALIZED:
-      {
+  function getOutlinedModel(response, id) {
+    var chunk = getChunk(response, id);
+
+    switch (chunk.status) {
+      case RESOLVED_MODEL:
+        initializeModelChunk(chunk);
+        break;
+    } // The status might have changed after initialization.
+
+    switch (chunk.status) {
+      case INITIALIZED: {
         return chunk.value;
       }
-    // We always encode it first in the stream so it won't be pending.
+      // We always encode it first in the stream so it won't be pending.
 
-    default:
-      throw chunk.reason;
+      default:
+        throw chunk.reason;
+    }
   }
-}
 
-function parseModelString(response, parentObject, key, value) {
-  if (value[0] === '$') {
-    if (value === '$') {
-      // A very common symbol.
-      return REACT_ELEMENT_TYPE;
-    }
+  function parseModelString(response, parentObject, key, value) {
+    if (value[0] === '$') {
+      if (value === '$') {
+        // A very common symbol.
+        return REACT_ELEMENT_TYPE;
+      }
 
-    switch (value[1]) {
-      case '$':
-        {
+      switch (value[1]) {
+        case '$': {
           // This was an escaped string value.
           return value.slice(1);
         }
 
-      case 'L':
-        {
+        case 'L': {
           // Lazy node
           var id = parseInt(value.slice(2), 16);
           var chunk = getChunk(response, id); // We create a React.lazy wrapper around any lazy values.
@@ -1558,8 +1602,7 @@ function parseModelString(response, parentObject, key, value) {
           return createLazyChunkWrapper(chunk);
         }
 
-      case '@':
-        {
+        case '@': {
           // Promise
           var _id = parseInt(value.slice(2), 16);
 
@@ -1568,20 +1611,17 @@ function parseModelString(response, parentObject, key, value) {
           return _chunk;
         }
 
-      case 'S':
-        {
+        case 'S': {
           // Symbol
           return Symbol.for(value.slice(2));
         }
 
-      case 'P':
-        {
+        case 'P': {
           // Server Context Provider
           return getOrCreateServerContext(value.slice(2)).Provider;
         }
 
-      case 'F':
-        {
+        case 'F': {
           // Server Reference
           var _id2 = parseInt(value.slice(2), 16);
 
@@ -1589,8 +1629,7 @@ function parseModelString(response, parentObject, key, value) {
           return createServerReferenceProxy(response, metadata);
         }
 
-      case 'Q':
-        {
+        case 'Q': {
           // Map
           var _id3 = parseInt(value.slice(2), 16);
 
@@ -1598,8 +1637,7 @@ function parseModelString(response, parentObject, key, value) {
           return new Map(data);
         }
 
-      case 'W':
-        {
+        case 'W': {
           // Set
           var _id4 = parseInt(value.slice(2), 16);
 
@@ -1608,14 +1646,12 @@ function parseModelString(response, parentObject, key, value) {
           return new Set(_data);
         }
 
-      case 'I':
-        {
+        case 'I': {
           // $Infinity
           return Infinity;
         }
 
-      case '-':
-        {
+        case '-': {
           // $-0 or $-Infinity
           if (value === '$-0') {
             return -0;
@@ -1624,33 +1660,28 @@ function parseModelString(response, parentObject, key, value) {
           }
         }
 
-      case 'N':
-        {
+        case 'N': {
           // $NaN
           return NaN;
         }
 
-      case 'u':
-        {
+        case 'u': {
           // matches "$undefined"
           // Special encoding for `undefined` which can't be serialized as JSON otherwise.
           return undefined;
         }
 
-      case 'D':
-        {
+        case 'D': {
           // Date
           return new Date(Date.parse(value.slice(2)));
         }
 
-      case 'n':
-        {
+        case 'n': {
           // BigInt
           return BigInt(value.slice(2));
         }
 
-      default:
-        {
+        default: {
           // We assume that anything else is a reference ID.
           var _id5 = parseInt(value.slice(1), 16);
 
@@ -1666,7 +1697,6 @@ function parseModelString(response, parentObject, key, value) {
               break;
           } // The status might have changed after initialization.
 
-
           switch (_chunk2.status) {
             case INITIALIZED:
               return _chunk2.value;
@@ -1676,7 +1706,10 @@ function parseModelString(response, parentObject, key, value) {
             case CYCLIC:
               var parentChunk = initializingChunk;
 
-              _chunk2.then(createModelResolver(parentChunk, parentObject, key, _chunk2.status === CYCLIC), createModelReject(parentChunk));
+              _chunk2.then(
+                createModelResolver(parentChunk, parentObject, key, _chunk2.status === CYCLIC),
+                createModelReject(parentChunk)
+              );
 
               return null;
 
@@ -1684,162 +1717,219 @@ function parseModelString(response, parentObject, key, value) {
               throw _chunk2.reason;
           }
         }
+      }
     }
-  }
-
-  return value;
-}
-
-function parseModelTuple(response, value) {
-  var tuple = value;
 
-  if (tuple[0] === REACT_ELEMENT_TYPE) {
-    // TODO: Consider having React just directly accept these arrays as elements.
-    // Or even change the ReactElement type to be an array.
-    return createElement(tuple[1], tuple[2], tuple[3]);
+    return value;
   }
 
-  return value;
-}
-
-function missingCall() {
-  throw new Error('Trying to call a function from "use server" but the callServer option ' + 'was not implemented in your router runtime.');
-}
+  function parseModelTuple(response, value) {
+    var tuple = value;
 
-function createResponse(bundlerConfig, moduleLoading, callServer, nonce) {
-  var chunks = new Map();
-  var response = {
-    _bundlerConfig: bundlerConfig,
-    _moduleLoading: moduleLoading,
-    _callServer: callServer !== undefined ? callServer : missingCall,
-    _nonce: nonce,
-    _chunks: chunks,
-    _stringDecoder: createStringDecoder(),
-    _fromJSON: null,
-    _rowState: 0,
-    _rowID: 0,
-    _rowTag: 0,
-    _rowLength: 0,
-    _buffer: []
-  }; // Don't inline this call because it causes closure to outline the call above.
+    if (tuple[0] === REACT_ELEMENT_TYPE) {
+      // TODO: Consider having React just directly accept these arrays as elements.
+      // Or even change the ReactElement type to be an array.
+      return createElement(tuple[1], tuple[2], tuple[3]);
+    }
 
-  response._fromJSON = createFromJSONCallback(response);
-  return response;
-}
+    return value;
+  }
 
-function resolveModel(response, id, model) {
-  var chunks = response._chunks;
-  var chunk = chunks.get(id);
+  function missingCall() {
+    throw new Error(
+      'Trying to call a function from "use server" but the callServer option ' +
+        'was not implemented in your router runtime.'
+    );
+  }
 
-  if (!chunk) {
-    chunks.set(id, createResolvedModelChunk(response, model));
-  } else {
-    resolveModelChunk(chunk, model);
+  function createResponse(bundlerConfig, moduleLoading, callServer, nonce) {
+    var chunks = new Map();
+    var response = {
+      _bundlerConfig: bundlerConfig,
+      _moduleLoading: moduleLoading,
+      _callServer: callServer !== undefined ? callServer : missingCall,
+      _nonce: nonce,
+      _chunks: chunks,
+      _stringDecoder: createStringDecoder(),
+      _fromJSON: null,
+      _rowState: 0,
+      _rowID: 0,
+      _rowTag: 0,
+      _rowLength: 0,
+      _buffer: [],
+    }; // Don't inline this call because it causes closure to outline the call above.
+
+    response._fromJSON = createFromJSONCallback(response);
+    return response;
   }
-}
 
-function resolveText(response, id, text) {
-  var chunks = response._chunks; // We assume that we always reference large strings after they've been
-  // emitted.
+  function resolveModel(response, id, model) {
+    var chunks = response._chunks;
+    var chunk = chunks.get(id);
 
-  chunks.set(id, createInitializedTextChunk(response, text));
-}
+    if (!chunk) {
+      console.log('| add chunk |:', id, model);
+      chunks.set(id, createResolvedModelChunk(response, model));
+    } else {
+      console.log('| resolve module chunk |:', id, model);
+      resolveModelChunk(chunk, model);
+    }
+  }
 
-function resolveModule(response, id, model) {
-  var chunks = response._chunks;
-  var chunk = chunks.get(id);
-  var clientReferenceMetadata = parseModel(response, model);
-  var clientReference = resolveClientReference(response._bundlerConfig, clientReferenceMetadata);
-  // For now we preload all modules as early as possible since it's likely
-  // that we'll need them.
+  function resolveText(response, id, text) {
+    var chunks = response._chunks; // We assume that we always reference large strings after they've been
+    // emitted.
 
-  var promise = preloadModule(clientReference);
+    chunks.set(id, createInitializedTextChunk(response, text));
+  }
 
-  if (promise) {
-    var blockedChunk;
+  function resolveModule(response, id, model) {
+    var chunks = response._chunks;
+    var chunk = chunks.get(id);
+    var clientReferenceMetadata = parseModel(response, model);
+    var clientReference = resolveClientReference(response._bundlerConfig, clientReferenceMetadata);
+    // For now we preload all modules as early as possible since it's likely
+    // that we'll need them.
+    var promise = preloadModule(clientReference);
+
+    console.log('| resolveModule |:', id);
+    if (promise) {
+      var blockedChunk;
+
+      if (!chunk) {
+        console.log('| add chunk |:', id, clientReference);
+        // Technically, we should just treat promise as the chunk in this
+        // case. Because it'll just behave as any other promise.
+        blockedChunk = createBlockedChunk(response);
+        chunks.set(id, blockedChunk);
+      } else {
+        // This can't actually happen because we don't have any forward
+        // references to modules.
+        blockedChunk = chunk;
+        blockedChunk.status = BLOCKED;
+      }
 
-    if (!chunk) {
-      // Technically, we should just treat promise as the chunk in this
-      // case. Because it'll just behave as any other promise.
-      blockedChunk = createBlockedChunk(response);
-      chunks.set(id, blockedChunk);
+      promise.then(
+        function () {
+          console.log('>> RESOLVED MODULE', clientReference);
+          return resolveModuleChunk(blockedChunk, clientReference);
+        },
+        function (error) {
+          console.log('|> ERROR | Resolving client ref |:', clientReference, error);
+          return triggerErrorOnChunk(blockedChunk, error);
+        }
+      );
     } else {
-      // This can't actually happen because we don't have any forward
-      // references to modules.
-      blockedChunk = chunk;
-      blockedChunk.status = BLOCKED;
+      if (!chunk) {
+        chunks.set(id, createResolvedModuleChunk(response, clientReference));
+      } else {
+        console.log('IMPOSSIBLE HAPPENED!', chunk, clientReference);
+        // This can't actually happen because we don't have any forward
+        // references to modules.
+        resolveModuleChunk(chunk, clientReference);
+      }
     }
+  }
+
+  function resolveErrorDev(response, id, digest, message, stack) {
+    var error = new Error(
+      message || 'An error occurred in the Server Components render but no message was provided'
+    );
+    error.stack = stack;
+    error.digest = digest;
+    var errorWithDigest = error;
+    var chunks = response._chunks;
+    var chunk = chunks.get(id);
 
-    promise.then(function () {
-      return resolveModuleChunk(blockedChunk, clientReference);
-    }, function (error) {
-      return triggerErrorOnChunk(blockedChunk, error);
-    });
-  } else {
     if (!chunk) {
-      chunks.set(id, createResolvedModuleChunk(response, clientReference));
+      chunks.set(id, createErrorChunk(response, errorWithDigest));
     } else {
-      // This can't actually happen because we don't have any forward
-      // references to modules.
-      resolveModuleChunk(chunk, clientReference);
+      triggerErrorOnChunk(chunk, errorWithDigest);
     }
   }
-}
 
-function resolveErrorDev(response, id, digest, message, stack) {
+  function resolveHint(response, code, model) {
+    var hintModel = parseModel(response, model);
+    dispatchHint(code, hintModel);
+  }
 
+  function processFullRowFromString(response, id, tag, chunk) {
+    const row = chunk;
 
-  var error = new Error(message || 'An error occurred in the Server Components render but no message was provided');
-  error.stack = stack;
-  error.digest = digest;
-  var errorWithDigest = error;
-  var chunks = response._chunks;
-  var chunk = chunks.get(id);
+    console.log('processFullRowFromString', id, tag, row);
 
-  if (!chunk) {
-    chunks.set(id, createErrorChunk(response, errorWithDigest));
-  } else {
-    triggerErrorOnChunk(chunk, errorWithDigest);
-  }
-}
+    switch (tag) {
+      case 73: /* "I" */
+      {
+        resolveModule(response, id, row);
+        return;
+      }
+
+      case 72: /* "H" */
+      {
+        var code = row[0];
+        resolveHint(response, code, row.slice(1));
+        return;
+      }
+
+      case 69: /* "E" */
+      {
+        var errorInfo = JSON.parse(row);
+
+        {
+          resolveErrorDev(response, id, errorInfo.digest, errorInfo.message, errorInfo.stack);
+        }
 
-function resolveHint(response, code, model) {
-  var hintModel = parseModel(response, model);
-  dispatchHint(code, hintModel);
-}
+        return;
+      }
 
-function processFullRow(response, id, tag, buffer, chunk) {
+      case 84: /* "T" */
+      {
+        resolveText(response, id, row);
+        return;
+      }
 
-  var stringDecoder = response._stringDecoder;
-  var row = '';
+      case 80:
+      /* "P" */
+      // Fallthrough
 
-  for (var i = 0; i < buffer.length; i++) {
-    row += readPartialStringChunk(stringDecoder, buffer[i]);
+      default: /* """ "{" "[" "t" "f" "n" "0" - "9" */
+      {
+        // We assume anything else is JSON.
+        resolveModel(response, id, row);
+        return;
+      }
+    }
   }
 
-  row += readFinalStringChunk(stringDecoder, chunk);
+  function processFullRow(response, id, tag, buffer, chunk) {
+    var stringDecoder = response._stringDecoder;
+    var row = '';
+
+    for (var i = 0; i < buffer.length; i++) {
+      row += readPartialStringChunk(stringDecoder, buffer[i]);
+    }
+
+    row += readFinalStringChunk(stringDecoder, chunk);
 
-  switch (tag) {
-    case 73
-    /* "I" */
-    :
+    // 1, 73, [], [91, 34, ...], ["http://localhost:8081/node_modules/react-native-web/dist/exports/View/index.js.bundle?platform=web&dev=true&hot=false&transform.engine=hermes&transform.routerRoot=src%2Fapp&modulesOnly=true&runModule=false#-79164580",["http://localhost:8081/node_modules/react-native-web/dist/exports/View/index.js.bundle?platform=web&dev=true&hot=false&transform.engine=hermes&transform.routerRoot=src%2Fapp&modulesOnly=true&runModule=false#-79164580"],""]
+    // console.log('processFullRow', id, tag, buffer, chunk, row)
+
+    switch (tag) {
+      case 73: /* "I" */
       {
         resolveModule(response, id, row);
         return;
       }
 
-    case 72
-    /* "H" */
-    :
+      case 72: /* "H" */
       {
         var code = row[0];
         resolveHint(response, code, row.slice(1));
         return;
       }
 
-    case 69
-    /* "E" */
-    :
+      case 69: /* "E" */
       {
         var errorInfo = JSON.parse(row);
 
@@ -1850,77 +1940,76 @@ function processFullRow(response, id, tag, buffer, chunk) {
         return;
       }
 
-    case 84
-    /* "T" */
-    :
+      case 84: /* "T" */
       {
+        // console.log('resolveText', id, row)
         resolveText(response, id, row);
         return;
       }
 
-    case 80
-    /* "P" */
-    :
-    // Fallthrough
+      case 80:
+      /* "P" */
+      // Fallthrough
 
-    default:
-      /* """ "{" "[" "t" "f" "n" "0" - "9" */
+      default: /* """ "{" "[" "t" "f" "n" "0" - "9" */
       {
         // We assume anything else is JSON.
         resolveModel(response, id, row);
         return;
       }
+    }
   }
-}
 
-function processBinaryChunk(response, chunk) {
-  var i = 0;
-  var rowState = response._rowState;
-  var rowID = response._rowID;
-  var rowTag = response._rowTag;
-  var rowLength = response._rowLength;
-  var buffer = response._buffer;
-  var chunkLength = chunk.length;
+  function processBinaryChunk(response, chunk) {
+    var i = 0;
+    var rowState = response._rowState;
+    var rowID = response._rowID;
+    var rowTag = response._rowTag;
+    var rowLength = response._rowLength;
+    var buffer = response._buffer;
+    var chunkLength = chunk.length;
 
-  while (i < chunkLength) {
-    var lastIdx = -1;
+    while (i < chunkLength) {
+      var lastIdx = -1;
 
-    switch (rowState) {
-      case ROW_ID:
-        {
+      switch (rowState) {
+        case ROW_ID: {
           var byte = chunk[i++];
 
-          if (byte === 58
-          /* ":" */
+          if (
+            byte === 58
+            /* ":" */
           ) {
-              // Finished the rowID, next we'll parse the tag.
-              rowState = ROW_TAG;
-            } else {
-            rowID = rowID << 4 | (byte > 96 ? byte - 87 : byte - 48);
+            // Finished the rowID, next we'll parse the tag.
+            rowState = ROW_TAG;
+          } else {
+            rowID = (rowID << 4) | (byte > 96 ? byte - 87 : byte - 48);
           }
 
           continue;
         }
 
-      case ROW_TAG:
-        {
+        case ROW_TAG: {
           var resolvedRowTag = chunk[i];
 
-          if (resolvedRowTag === 84
-          /* "T" */
-          || enableBinaryFlight 
-          /* "V" */
+          if (
+            resolvedRowTag === 84 ||
+            /* "T" */
+            enableBinaryFlight
+            /* "V" */
           ) {
-              rowTag = resolvedRowTag;
-              rowState = ROW_LENGTH;
-              i++;
-            } else if (resolvedRowTag > 64 && resolvedRowTag < 91
-          /* "A"-"Z" */
+            rowTag = resolvedRowTag;
+            rowState = ROW_LENGTH;
+            i++;
+          } else if (
+            resolvedRowTag > 64 &&
+            resolvedRowTag < 91
+            /* "A"-"Z" */
           ) {
-              rowTag = resolvedRowTag;
-              rowState = ROW_CHUNK_BY_NEWLINE;
-              i++;
-            } else {
+            rowTag = resolvedRowTag;
+            rowState = ROW_CHUNK_BY_NEWLINE;
+            i++;
+          } else {
             rowTag = 0;
             rowState = ROW_CHUNK_BY_NEWLINE; // This was an unknown tag so it was probably part of the data.
           }
@@ -1928,33 +2017,33 @@ function processBinaryChunk(response, chunk) {
           continue;
         }
 
-      case ROW_LENGTH:
-        {
+        case ROW_LENGTH: {
           var _byte = chunk[i++];
 
-          if (_byte === 44
-          /* "," */
+          if (
+            _byte === 44
+            /* "," */
           ) {
-              // Finished the rowLength, next we'll buffer up to that length.
-              rowState = ROW_CHUNK_BY_LENGTH;
-            } else {
-            rowLength = rowLength << 4 | (_byte > 96 ? _byte - 87 : _byte - 48);
+            // Finished the rowLength, next we'll buffer up to that length.
+            rowState = ROW_CHUNK_BY_LENGTH;
+          } else {
+            rowLength = (rowLength << 4) | (_byte > 96 ? _byte - 87 : _byte - 48);
           }
 
           continue;
         }
 
-      case ROW_CHUNK_BY_NEWLINE:
-        {
+        case ROW_CHUNK_BY_NEWLINE: {
           // We're looking for a newline
-          lastIdx = chunk.indexOf(10
-          /* "\n" */
-          , i);
+          lastIdx = chunk.indexOf(
+            10,
+            /* "\n" */
+            i
+          );
           break;
         }
 
-      case ROW_CHUNK_BY_LENGTH:
-        {
+        case ROW_CHUNK_BY_LENGTH: {
           // We're looking for the remaining byte length
           lastIdx = i + rowLength;
 
@@ -1964,132 +2053,208 @@ function processBinaryChunk(response, chunk) {
 
           break;
         }
+      }
+
+      var offset = chunk.byteOffset + i;
+
+      if (lastIdx > -1) {
+        // We found the last chunk of the row
+        var length = lastIdx - i;
+        var lastChunk = new Uint8Array(chunk.buffer, offset, length);
+        processFullRow(response, rowID, rowTag, buffer, lastChunk); // Reset state machine for a new row
+
+        i = lastIdx;
+
+        if (rowState === ROW_CHUNK_BY_NEWLINE) {
+          // If we're trailing by a newline we need to skip it.
+          i++;
+        }
+
+        rowState = ROW_ID;
+        rowTag = 0;
+        rowID = 0;
+        rowLength = 0;
+        buffer.length = 0;
+      } else {
+        // The rest of this row is in a future chunk. We stash the rest of the
+        // current chunk until we can process the full row.
+        var _length = chunk.byteLength - i;
+
+        var remainingSlice = new Uint8Array(chunk.buffer, offset, _length);
+        buffer.push(remainingSlice); // Update how many bytes we're still waiting for. If we're looking for
+        // a newline, this doesn't hurt since we'll just ignore it.
+
+        rowLength -= remainingSlice.byteLength;
+        break;
+      }
     }
 
-    var offset = chunk.byteOffset + i;
+    response._rowState = rowState;
+    response._rowID = rowID;
+    response._rowTag = rowTag;
+    response._rowLength = rowLength;
+  }
 
-    if (lastIdx > -1) {
-      // We found the last chunk of the row
-      var length = lastIdx - i;
-      var lastChunk = new Uint8Array(chunk.buffer, offset, length);
-      processFullRow(response, rowID, rowTag, buffer, lastChunk); // Reset state machine for a new row
+  function parseModel(response, json) {
+    // console.log('parseModel', json)
+    return JSON.parse(json, response._fromJSON);
+  }
 
-      i = lastIdx;
+  function createFromJSONCallback(response) {
+    // $FlowFixMe[missing-this-annot]
+    return function (key, value) {
+      if (typeof value === 'string') {
+        // We can't use .bind here because we need the "this" value.
+        return parseModelString(response, this, key, value);
+      }
 
-      if (rowState === ROW_CHUNK_BY_NEWLINE) {
-        // If we're trailing by a newline we need to skip it.
-        i++;
+      if (typeof value === 'object' && value !== null) {
+        return parseModelTuple(response, value);
       }
 
-      rowState = ROW_ID;
-      rowTag = 0;
-      rowID = 0;
-      rowLength = 0;
-      buffer.length = 0;
-    } else {
-      // The rest of this row is in a future chunk. We stash the rest of the
-      // current chunk until we can process the full row.
-      var _length = chunk.byteLength - i;
+      return value;
+    };
+  }
 
-      var remainingSlice = new Uint8Array(chunk.buffer, offset, _length);
-      buffer.push(remainingSlice); // Update how many bytes we're still waiting for. If we're looking for
-      // a newline, this doesn't hurt since we'll just ignore it.
+  function close(response) {
+    // In case there are any remaining unresolved chunks, they won't
+    // be resolved now. So we need to issue an error to those.
+    // Ideally we should be able to early bail out if we kept a
+    // ref count of pending chunks.
+    reportGlobalError(response, new Error('Connection closed.'));
+  }
 
-      rowLength -= remainingSlice.byteLength;
-      break;
-    }
+  function createResponseFromOptions(options) {
+    return createResponse(
+      null,
+      null,
+      options && options.callServer ? options.callServer : undefined,
+      undefined // nonce
+    );
   }
 
-  response._rowState = rowState;
-  response._rowID = rowID;
-  response._rowTag = rowTag;
-  response._rowLength = rowLength;
-}
+  function startReadingFromText(response, stream) {
+    // Hack: convert string to text and parse it as JSON.
+
+    function progress(_ref) {
+      console.log('progress:', _ref);
+      _ref
+        .split('\n')
+        .filter(Boolean)
+        .forEach((buffer, index) => {
+          const line = buffer.match(/^([\d:A-Z]+)(.*)/);
+
+          const prefix = line[1];
+          const [, typeCode = 0] = prefix.split(':');
+          const cleanChunk = line[2];
+
+          let rowID = 0;
+          if (typeCode) {
+            // Convert char like "I" to 73
+            rowID = typeCode.charCodeAt(0);
+          }
+          const rowTag = Number(buffer[0]);
 
-function parseModel(response, json) {
-  return JSON.parse(json, response._fromJSON);
-}
+          console.log('>>>LINE:', prefix, rowID, rowTag, cleanChunk);
+          // BACONHACK
+          processFullRowFromString(response, rowTag, rowID, cleanChunk);
+        });
 
-function createFromJSONCallback(response) {
-  // $FlowFixMe[missing-this-annot]
-  return function (key, value) {
-    if (typeof value === 'string') {
-      // We can't use .bind here because we need the "this" value.
-      return parseModelString(response, this, key, value);
+      close(response);
     }
 
-    if (typeof value === 'object' && value !== null) {
-      return parseModelTuple(response, value);
+    function error(e) {
+      reportGlobalError(response, e);
     }
 
-    return value;
-  };
-}
-
-function close(response) {
-  // In case there are any remaining unresolved chunks, they won't
-  // be resolved now. So we need to issue an error to those.
-  // Ideally we should be able to early bail out if we kept a
-  // ref count of pending chunks.
-  reportGlobalError(response, new Error('Connection closed.'));
-}
-
-function createResponseFromOptions(options) {
-  return createResponse(null, null, options && options.callServer ? options.callServer : undefined, undefined // nonce
-  );
-}
-
-function startReadingFromStream(response, stream) {
-  var reader = stream.getReader();
-
-  function progress(_ref) {
-    var done = _ref.done,
+    stream.text().then(progress).catch(error);
+
+    // var reader = stream.getReader();
+
+    // function progress(_ref) {
+    //   var done = _ref.done,
+    //       value = _ref.value;
+
+    //   if (done) {
+    //     close(response);
+    //     return;
+    //   }
+
+    //   var buffer = value;
+    //   processBinaryChunk(response, buffer);
+    //   return reader.read().then(progress).catch(error);
+    // }
+
+    // function error(e) {
+    //   reportGlobalError(response, e);
+    // }
+
+    // reader.read().then(progress).catch(error);
+  }
+
+  function startReadingFromStream(response, stream) {
+    // Hack: convert string to text and parse it as JSON.
+    console.log('startReadingFromStream', response, stream);
+    // var text = stream.read();
+    //
+
+    var reader = stream.getReader();
+
+    function progress(_ref) {
+      var done = _ref.done,
         value = _ref.value;
 
-    if (done) {
-      close(response);
-      return;
+      if (done) {
+        close(response);
+        return;
+      }
+
+      var buffer = value;
+      processBinaryChunk(response, buffer);
+      return reader.read().then(progress).catch(error);
     }
 
-    var buffer = value;
-    processBinaryChunk(response, buffer);
-    return reader.read().then(progress).catch(error);
-  }
-
-  function error(e) {
-    reportGlobalError(response, e);
-  }
-
-  reader.read().then(progress).catch(error);
-}
-
-function createFromReadableStream(stream, options) {
-  var response = createResponseFromOptions(options);
-  startReadingFromStream(response, stream);
-  return getRoot(response);
-}
-
-function createFromFetch(promiseForResponse, options) {
-  var response = createResponseFromOptions(options);
-  promiseForResponse.then(function (r) {
-    startReadingFromStream(response, r.body);
-  }, function (e) {
-    reportGlobalError(response, e);
-  });
-  return getRoot(response);
-}
-
-function encodeReply(value)
-/* We don't use URLSearchParams yet but maybe */
-{
-  return new Promise(function (resolve, reject) {
-    processReply(value, '', resolve, reject);
-  });
-}
-
-exports.createFromFetch = createFromFetch;
-exports.createFromReadableStream = createFromReadableStream;
-exports.createServerReference = createServerReference;
-exports.encodeReply = encodeReply;
-  })();
-}
+    function error(e) {
+      reportGlobalError(response, e);
+    }
+
+    reader.read().then(progress).catch(error);
+  }
+
+  function createFromReadableStream(stream, options) {
+    var response = createResponseFromOptions(options);
+    startReadingFromStream(response, stream);
+    return getRoot(response);
+  }
+
+  function createFromFetch(promiseForResponse, options) {
+    var response = createResponseFromOptions(options);
+    promiseForResponse.then(
+      function (r) {
+        console.log('>>promiseForResponse:', !!r.body);
+        if (r.body) {
+          startReadingFromStream(response, r.body);
+        } else {
+          startReadingFromText(response, r);
+        }
+      },
+      function (e) {
+        reportGlobalError(response, e);
+      }
+    );
+    return getRoot(response);
+  }
+
+  function encodeReply(value) /* We don't use URLSearchParams yet but maybe */
+  {
+    return new Promise(function (resolve, reject) {
+      processReply(value, '', resolve, reject);
+    });
+  }
+
+  exports.createFromFetch = createFromFetch;
+  exports.createFromReadableStream = createFromReadableStream;
+  exports.createServerReference = createServerReference;
+  exports.encodeReply = encodeReply;
+})();
+// }
diff --git a/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-client.node.unbundled.production.min.js b/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-client.node.unbundled.production.min.js
index 0b8079e..8738260 100644
--- a/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-client.node.unbundled.production.min.js
+++ b/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-client.node.unbundled.production.min.js
@@ -8,7 +8,7 @@
  LICENSE file in the root directory of this source tree.
 */
 'use strict';var p=require("util"),r=require("react-dom"),u=require("react"),v={stream:!0};function w(a,b){var d=a[b[0]];if(a=d[b[2]])d=a.name;else{a=d["*"];if(!a)throw Error('Could not find the module "'+b[0]+'" in the React SSR Manifest. This is probably a bug in the React Server Components bundler.');d=b[2]}return{specifier:a.specifier,name:d,async:4===b.length}}var x=new Map;
-function y(a){var b=x.get(a.specifier);if(b)return"fulfilled"===b.status?null:b;var d=import(a.specifier);a.async&&(d=d.then(function(c){return c.default}));d.then(function(c){var g=d;g.status="fulfilled";g.value=c},function(c){var g=d;g.status="rejected";g.reason=c});x.set(a.specifier,d);return d}
+function y(a){var b=x.get(a.specifier);if(b)return"fulfilled"===b.status?null:b;var d=__r(a.specifier);a.async&&(d=d.then(function(c){return c.default}));d.then(function(c){var g=d;g.status="fulfilled";g.value=c},function(c){var g=d;g.status="rejected";g.reason=c});x.set(a.specifier,d);return d}
 function z(a,b,d){if(null!==a)for(var c=1;c<b.length;c+=2){var g=d,h=A.current;if(h){var l=h.preinitScript,k=a.prefix+b[c];var e=a.crossOrigin;e="string"===typeof e?"use-credentials"===e?e:"":void 0;l.call(h,k,{crossOrigin:e,nonce:g})}}}var A=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Dispatcher,B=Symbol.for("react.element"),C=Symbol.for("react.provider"),D=Symbol.for("react.server_context"),F=Symbol.for("react.lazy"),G=Symbol.for("react.default_value"),H=Symbol.iterator;
 function aa(a){if(null===a||"object"!==typeof a)return null;a=H&&a[H]||a["@@iterator"];return"function"===typeof a?a:null}var ba=Array.isArray,I=Object.getPrototypeOf,ca=Object.prototype,J=new WeakMap;function da(a){return Number.isFinite(a)?0===a&&-Infinity===1/a?"$-0":a:Infinity===a?"$Infinity":-Infinity===a?"$-Infinity":"$NaN"}
 function ea(a,b,d,c){function g(e,f){if(null===f)return null;if("object"===typeof f){if("function"===typeof f.then){null===k&&(k=new FormData);l++;var t=h++;f.then(function(n){n=JSON.stringify(n,g);var q=k;q.append(b+t,n);l--;0===l&&d(q)},function(n){c(n)});return"$@"+t.toString(16)}if(ba(f))return f;if(f instanceof FormData){null===k&&(k=new FormData);var E=k;e=h++;var m=b+e+"_";f.forEach(function(n,q){E.append(m+q,n)});return"$K"+e.toString(16)}if(f instanceof Map)return f=JSON.stringify(Array.from(f),
diff --git a/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.development.js b/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.development.js
index 5d78b6a..a63e228 100644
--- a/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.development.js
+++ b/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.development.js
@@ -2783,7 +2783,7 @@ function preloadModule(metadata) {
     return existingPromise;
   } else {
     // $FlowFixMe[unsupported-syntax]
-    var modulePromise = import(metadata.specifier);
+    var modulePromise = __r(metadata.specifier);
 
     if (metadata.async) {
       // If the module is async, it must have been a CJS module.
diff --git a/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.production.min.js b/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.production.min.js
index f52adc8..e8b924c 100644
--- a/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.production.min.js
+++ b/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.production.min.js
@@ -61,7 +61,7 @@ function R(a,b){l=new Uint8Array(2048);m=0;p=!0;try{for(var d=a.completedImportC
 null;c++;break}g.splice(0,c)}finally{a.flushScheduled=!1,l&&0<m&&b.write(l.subarray(0,m)),l=null,m=0,p=!0}"function"===typeof b.flush&&b.flush();0===a.pendingChunks&&b.end()}function tb(a){a.flushScheduled=null!==a.destination;setImmediate(function(){return xa.run(a,ob,a)})}function lb(a){if(!1===a.flushScheduled&&0===a.pingedTasks.length&&null!==a.destination){var b=a.destination;a.flushScheduled=!0;setImmediate(function(){return R(a,b)})}}
 function ub(a,b){if(1===a.status)a.status=2,b.destroy(a.fatalError);else if(2!==a.status&&null===a.destination){a.destination=b;try{R(a,b)}catch(d){P(a,d),sb(a,d)}}}
 function vb(a,b){try{var d=a.abortableTasks;if(0<d.size){a.pendingChunks++;var c=a.nextChunkId++,e=void 0===b?Error("The render was aborted by the server without a reason."):b,f=P(a,e);Q(a,c,f,e);d.forEach(function(g){g.status=3;var k=T(c);g=pb(a,g.id,k);a.completedErrorChunks.push(g)});d.clear()}null!==a.destination&&R(a,a.destination)}catch(g){P(a,g),sb(a,g)}}function wb(a,b){var d=b.lastIndexOf("#");a=b.slice(0,d);b=b.slice(d+1);return{specifier:a,name:b}}var xb=new Map;
-function yb(a){var b=xb.get(a.specifier);if(b)return"fulfilled"===b.status?null:b;var d=import(a.specifier);a.async&&(d=d.then(function(c){return c.default}));d.then(function(c){var e=d;e.status="fulfilled";e.value=c},function(c){var e=d;e.status="rejected";e.reason=c});xb.set(a.specifier,d);return d}function W(a){var b=xb.get(a.specifier);if("fulfilled"===b.status)b=b.value;else throw b.reason;return"*"===a.name?b:""===a.name?b.default:b[a.name]}
+function yb(a){var b=xb.get(a.specifier);if(b)return"fulfilled"===b.status?null:b;var d=__r(a.specifier);a.async&&(d=d.then(function(c){return c.default}));d.then(function(c){var e=d;e.status="fulfilled";e.value=c},function(c){var e=d;e.status="rejected";e.reason=c});xb.set(a.specifier,d);return d}function W(a){var b=xb.get(a.specifier);if("fulfilled"===b.status)b=b.value;else throw b.reason;return"*"===a.name?b:""===a.name?b.default:b[a.name]}
 function zb(a,b,d,c){this.status=a;this.value=b;this.reason=d;this._response=c}zb.prototype=Object.create(Promise.prototype);zb.prototype.then=function(a,b){switch(this.status){case "resolved_model":Ab(this)}switch(this.status){case "fulfilled":a(this.value);break;case "pending":case "blocked":a&&(null===this.value&&(this.value=[]),this.value.push(a));b&&(null===this.reason&&(this.reason=[]),this.reason.push(b));break;default:b(this.reason)}};
 function Bb(a,b){for(var d=0;d<a.length;d++)(0,a[d])(b)}function Cb(a,b){if("pending"===a.status||"blocked"===a.status){var d=a.reason;a.status="rejected";a.reason=b;null!==d&&Bb(d,b)}}function Db(a,b,d,c,e,f){var g=wb(a._bundlerConfig,b);a=yb(g);if(d)d=Promise.all([d,a]).then(function(k){k=k[0];var h=W(g);return h.bind.apply(h,[null].concat(k))});else if(a)d=Promise.resolve(a).then(function(){return W(g)});else return W(g);d.then(Eb(c,e,f),Fb(c));return null}var X=null,Y=null;
 function Ab(a){var b=X,d=Y;X=a;Y=null;try{var c=JSON.parse(a.value,a._response._fromJSON);null!==Y&&0<Y.deps?(Y.value=c,a.status="blocked",a.value=null,a.reason=null):(a.status="fulfilled",a.value=c)}catch(e){a.status="rejected",a.reason=e}finally{X=b,Y=d}}function Gb(a,b){a._chunks.forEach(function(d){"pending"===d.status&&Cb(d,b)})}
diff --git a/node_modules/react-server-dom-webpack/client.browser.js b/node_modules/react-server-dom-webpack/client.browser.js
index 9a80cea..ac65947 100644
--- a/node_modules/react-server-dom-webpack/client.browser.js
+++ b/node_modules/react-server-dom-webpack/client.browser.js
@@ -1,7 +1,7 @@
 'use strict';
 
-if (process.env.NODE_ENV === 'production') {
-  module.exports = require('./cjs/react-server-dom-webpack-client.browser.production.min.js');
-} else {
-  module.exports = require('./cjs/react-server-dom-webpack-client.browser.development.js');
-}
+// if (process.env.NODE_ENV === 'production') {
+//   module.exports = require('./cjs/react-server-dom-webpack-client.browser.production.min.js');
+// } else {
+// }
+module.exports = require('./cjs/react-server-dom-webpack-client.browser.development.js');

---
title: API Routes
description: Learn how to create universal serverless functions with Expo Router.
---

import { FileTree } from '~/ui/components/FileTree';
import { Step } from '~/ui/components/Step';
import { Terminal } from '~/ui/components/Snippet';
import { Collapsible } from '~/ui/components/Collapsible';

Expo Router supports enables you to write universal backend server code directly in your app.

```json app.json
{
  "expo": {
    "web": {
      "bundler": "metro",
      /* @info Output a dynamic server. */
      "output": "server"
      /* @end */
    }
  }
}
```

Server features require a custom Node.js server to work. Most hosting providers support Node.js, including [Netlify](https://netlify.com), [Vercel](https://vercel.com), and [Heroku](https://heroku.com).

## Usage

> While in beta, server code may leak into the client bundle. This won't happen in the stable release.

Server Routes are functions that are executed when a route is matched. They can be used to securely handle sensitive data, such as API keys, or to implement custom server logic. Server Routes should be executed in a [WinterCG](https://wintercg.org/) environment.

Server Routes are defined by creating files in the `app` directory with the `+api.js` extension. For example, the following route handler will be executed when the route `/hello` is matched.

<FileTree files={['app/index.js', ['app/hello+api.ts', 'Server Route']]} />

<Step label="1">

Create a server route in the `app` directory.

```js app/hello+api.ts
import { ExpoRequest, ExpoResponse } from 'expo-router/server';

export function GET(request: ExpoRequest) {
  return ExpoResponse.json({ hello: 'world' });
}
```

You can export any of the following functions `GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS` from a server route. The function will be executed when the corresponding HTTP method is matched.

</Step>

<Step label="2">

Start the development server.

<Terminal cmd={['$ npx expo start']} />

</Step>

<Step label="3">

To access the data, you can make a network request to the route. For example, the following code will make a request to the route handler above.

```js
async function fetchHello() {
  const response = await fetch('/hello');
  const data = await response.json();
  console.log(data);
}
```

This won't work by default on native as `/api/hello` does not provide an origin URL. Follow the setup guide in [`window.location`](/docs/lab/runtime-location) to polyfill the `window.location` API.

```json app.json
{
  "expo": {
    "plugins": [
      [
        "expo-router",
        {
          "origin": "https://example.com"
        }
      ]
    ]
  }
}
```

</Step>

<Step label="4">

    Deploy the website to a [hosting provider](/distribution/publishing-websites) in order to access the routes in production on both web and native.

</Step>

## Requests

Requests use the global `ExpoRequest` object. This object is a subclass of the standard [`Request`][wcg-request] object and provides additional functionality. Specifically the `expoUrl` object, which is a `URL` that has access to query parameters according to the Expo Router file convention.

```ts app/blog/[post]+api.ts
import { ExpoRequest, ExpoResponse } from 'expo-router/server';

export async function GET(request: ExpoRequest, { post }: Record<string, string>) {
  // const postId = request.expoUrl.searchParams.get('post')
  // fetch data for `post`
  return ExpoResponse.json({ ... });
}
```

### Request body

Use the `request.json()` function to access the request body. This function will automatically parse the body and return the result.

```ts app/validate+api.ts
import { ExpoRequest, ExpoResponse } from 'expo-router/server';

export async function POST(request: ExpoRequest) {
  const body = await request.json();

  return ExpoResponse.json({ ... });
}
```

## Response

Responses use the global `ExpoResponse` object. This object is a subclass of the standard [`Response`][wcg-response] object and provides additional functionality. Specifically the `ExpoResponse.json` initializer which will automatically stringify the response body and return status 200.

```ts app/demo+api.ts
import { ExpoRequest, ExpoResponse } from 'expo-router/server';

export async function GET() {
  return ExpoResponse.json({ hello: 'universe' });
}
```

## Errors

You can respond with server errors by using the `ExpoResponse` object.

```ts app/blog/[post].ts
import { ExpoRequest, ExpoResponse } from 'expo-router/server';

export async function GET(request: ExpoRequest, { post }: Record<string, string>) {
  if (!post) {
    return new ExpoResponse('No post found', {
      status: 404,
      headers: {
        'Content-Type': 'text/plain',
      },
    });
  }
  // fetch data for `post`
  return ExpoResponse.json({ ... });
}
```

Making requests with an undefined method will automatically return `405: Method not allowed`.

If an error is thrown during the request, it will automatically return `500: Internal server error`.

## Bundling

API Routes are bundled with Metro, meaning they have access to all of the same bundling features as your client code.

- [TypeScript](/guides/typescript) –– types and [`tsconfig.json` paths](/guides/typescript#path-aliases).
- [Environment variables](/guides/environment-variables) –– server routes have access to all environment variables, not just the ones prefixed with `EXPO_PUBLIC_`.
- Node.js standard library –– ensure that you are using the correct version of Node.js locally for your server environment.
- `babel.config.js` and `metro.config.js` support –– settings work across both client and server code.

{/* TODO: SSR, redirects, middleware, etc. */}

## Security

> While in beta, server code may leak into the client bundle. This won't happen in the stable release.

Route handlers are executed in a sandboxed environment that is isolated from the client code. This means that you can safely store sensitive data in the route handlers without exposing it to the client.

- If your client code imports code with a secret, it will still be included in the client bundle. This also applies to ALL files in the `app` directory that are not a route handler (suffixed with `+api.js`).
- If your secret is in a `<...>+api.js` (Route Handler) file, it will not be included in the client bundle. This applies to all files that are imported in the route handler.
- The secret stripping takes place in `expo/metro-config` and requires this be used in your `metro.config.js`!

## Deployment

> This is experimental and subject to breaking changes. We have no continuous tests against this configuration.

Every cloud hosting provider needs a custom adapter to support the Expo server runtime. The following providers have unofficial/experimental support from the Expo team.

Before you deploy with third-parties, it's good to be familiar with the basics of the [`npx expo export`](/more/expo-cli#exporting) command. Specifically:

- `/dist` is the default export directory for Expo CLI.
- Files in `/public` will be copied to `/dist` on export.
- The `@expo/server` package is included with `expo` and delegates requests to the server routes.
- `@expo/server` does **not** inflate environment variables from `.env` files, these are expected to be loaded either by the hosting provider or the user.
- Metro is not included in the server.

### Express

<Step label="1">

Install the required dependencies:

<Terminal cmd={['$ yarn add -D express compression morgan']} />

</Step>

<Step label="2">

Export the website for production.

<Terminal cmd={['$ yarn expo export -p web']} />

</Step>

<Step label="3">

Write a server entry file that serves the static files and delegates requests to the server routes.

```js server.js
#!/usr/bin/env node

const path = require('path');
const { createRequestHandler } = require('@expo/server/build/vendor/express');

const express = require('express');
const compression = require('compression');
const morgan = require('morgan');

const BUILD_DIR = path.join(process.cwd(), 'dist');

const app = express();

app.use(compression());

// http://expressjs.com/en/advanced/best-practice-security.html#at-a-minimum-disable-x-powered-by-header
app.disable('x-powered-by');

process.env.NODE_ENV = 'production';

app.use(
  // Prevent access to expo functions as these may
  // contain sensitive information.
  [/^\/_expo\/functions($|\/)/, '/'],
  express.static(BUILD_DIR, {
    maxAge: '1h',
    extensions: ['html'],
  })
);

app.use(morgan('tiny'));

app.all(
  '*',
  createRequestHandler({
    build: BUILD_DIR,
  })
);
const port = process.env.PORT || 3000;

app.listen(port, () => {
  console.log(`Express server listening on port ${port}`);
});
```

</Step>

<Step label="4">

Start the server with `node`:

<Terminal cmd={['$ node server.js']} />

</Step>

### Netlify

> This is experimental and subject to breaking changes. We have no continuous tests against this configuration.

<Step label="1">

Create a server entry file, all requests will be delegated through this middleware. The exact file location is important.

```js netlify/functions/server.js
const { createRequestHandler } = require('@expo/server/build/vendor/netlify');

const handler = createRequestHandler({
  /* @info Points to the root `dist/` (output) folder */
  build: require('path').join(__dirname, '../../dist'),
  /* @end */
  mode: process.env.NODE_ENV,
});

module.exports = { handler };
```

</Step>

<Step label="2">

Create a Netlify configuration file to redirect all requests to the server function.

```toml netlify.toml
[build]
  command = "expo export -p web"
  functions = "netlify/functions"
  publish = "dist"

[[redirects]]
  from = "/*"
  to = "/.netlify/functions/server"
  status = 404

[functions]
  # Include everything to ensure dynamic routes can be used.
  included_files = ["dist/**/*"]

[[headers]]
  for = "/dist/_expo/functions/*"
  [headers.values]
    # Set to 60 seconds as an example.
    "Cache-Control" = "public, max-age=60, s-maxage=60"
```

</Step>

<Step label="3">

After you have created the configuration files, you can build the website and functions with Expo CLI:

<Terminal cmd={['$ yarn expo export -p web']} />

</Step>

<Step label="4">

Deploy to Netlify with the [Netlify CLI](https://docs.netlify.com/cli/get-started/).

<Terminal
  cmd={[
    '# Install the Netlify CLI globally if needed.',
    '$ npm install netlify-cli -g',
    '# Deploy the website.',
    '$ netlify deploy',
  ]}
/>

You can now visit your website at the URL provided by Netlify CLI. Running `netlify deploy --prod` will publish to the production URL.

</Step>

[wcg-request]: https://fetch.spec.whatwg.org/#request
[wcg-response]: https://fetch.spec.whatwg.org/#response

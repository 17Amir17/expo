---
title: API Routes
description: Learn how to create server functions with Expo Router.
---

> **info** This feature is still experimental. Available from Expo SDK 50 and Expo Router v3.

import { FileTree } from '~/ui/components/FileTree';
import { Step } from '~/ui/components/Step';
import { Terminal } from '~/ui/components/Snippet';
import { Collapsible } from '~/ui/components/Collapsible';

Expo Router enables you to write server code for all platforms, right in your **app** directory.

```json app.json
{
  "web": {
    "bundler": "metro",
    /* @info Output a dynamic server. */
    "output": "server"
    /* @end */
  }
}
```

Server features require a custom Node.js server. Most hosting providers support Node.js, including [Netlify](#netlify), [Cloudflare](https://www.cloudflare.com/), and [Vercel](https://vercel.com).

## API Routes

API Routes are functions that are executed when a route is matched. They can be used to securely handle sensitive data, such as API keys, or to implement custom server logic. API Routes should be executed in a [WinterCG](https://wintercg.org/)-compliant environment.

API Routes are defined by creating files in the `app` directory with the `+api.js` extension. For example, the following route handler will be executed when the route `/hello` is matched.

<FileTree files={['app/index.js', ['app/hello+api.ts', 'API Route']]} />

<Step label="1">

Create an API route in the `app` directory. The following route handler will be executed when the route `/hello` is matched.

```js app/hello+api.ts
import { ExpoRequest, ExpoResponse } from 'expo-router/server';

export function GET(request: ExpoRequest) {
  return ExpoResponse.json({ hello: 'world' });
}
```

You can export any of the following functions `GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS` from a server route. The function will be executed when the corresponding HTTP method is matched. Unsupported methods will automatically return `405: Method not allowed`.

</Step>

<Step label="2">

Start the development server with Expo CLI:

<Terminal cmd={['$ npx expo']} />

</Step>

<Step label="3">

To access the data, you can make a network request to the route. You can run the following in the terminal to quickly test the route:

<Terminal cmd={['$ curl http://localhost:8081/hello']} />

You can also make a request from the client code:

```js app/index.js
import { Button } from 'react-native';

async function fetchHello() {
  const response = await fetch('/hello');
  const data = await response.json();
  alert('Hello ' + data.hello);
}

export default function App() {
  return <Button onPress={() => fetchHello()} title="Fetch hello" />;
}
```

This won't work by default on native as `/hello` does not provide an origin URL. You can configure the origin URL in `app.json`, this can be a mock URL in development:

```json app.json
{
  "plugins": [
    [
      "expo-router",
      {
        /* @info The URL where the API routes are hosted at. */
        "origin": "https://mywebsite.netlify.app/"
        /* @end */
      }
    ]
  ]
}
```

</Step>

<Step label="4">

    Deploy the website and server to a [hosting provider](#deployment) in order to access the routes in production on both web and native.

</Step>

## Requests

Requests use the global `ExpoRequest` object. This object is a subclass of the standard [`Request`][wcg-request] object and provides additional functionality. Specifically the `expoUrl` object, which is a `URL` that has access to query parameters according to the Expo Router file convention.

```ts app/blog/[post]+api.ts
import { ExpoRequest, ExpoResponse } from 'expo-router/server';

export async function GET(request: ExpoRequest, { post }: Record<string, string>) {
  // const postId = request.expoUrl.searchParams.get('post')
  // fetch data for `post`
  return ExpoResponse.json({ ... });
}
```

### Request body

Use the `request.json()` function to access the request body. This function will automatically parse the body and return the result.

```ts app/validate+api.ts
import { ExpoRequest, ExpoResponse } from 'expo-router/server';

export async function POST(request: ExpoRequest) {
  const body = await request.json();

  return ExpoResponse.json({ ... });
}
```

## Response

Responses use the global `ExpoResponse` object. This object is a subclass of the standard [`Response`][wcg-response] object and provides additional functionality. Specifically the `ExpoResponse.json` initializer which will automatically stringify the response body and return status 200.

```ts app/demo+api.ts
import { ExpoRequest, ExpoResponse } from 'expo-router/server';

export function GET() {
  return ExpoResponse.json({ hello: 'universe' });
}
```

## Errors

You can respond with server errors by using the `ExpoResponse` object.

```ts app/blog/[post].ts
import { ExpoRequest, ExpoResponse } from 'expo-router/server';

export async function GET(request: ExpoRequest, { post }: Record<string, string>) {
  if (!post) {
    return new ExpoResponse('No post found', {
      status: 404,
      headers: {
        'Content-Type': 'text/plain',
      },
    });
  }
  // fetch data for `post`
  return ExpoResponse.json({ ... });
}
```

Making requests with an undefined method will automatically return `405: Method not allowed`.

If an error is thrown during the request, it will automatically return `500: Internal server error`.

## Bundling

API Routes are bundled with Expo CLI and [Metro bundler](/guides/customizing-metro), meaning they have access to all of the same language features as your client code.

- [TypeScript](/guides/typescript) –– types and [`tsconfig.json` paths](/guides/typescript#path-aliases).
- [Environment variables](/guides/environment-variables) –– server routes have access to all environment variables, not just the ones prefixed with `EXPO_PUBLIC_`.
- Node.js standard library –– ensure that you are using the correct version of Node.js locally for your server environment.
- `babel.config.js` and `metro.config.js` support –– settings work across both client and server code.

{/* TODO: SSR, redirects, middleware, etc. */}

## Security

> While in beta, server code may leak into the client bundle. This won't happen in the stable release.

Route handlers are executed in a sandboxed environment that is isolated from the client code. This means that you can safely store sensitive data in the route handlers without exposing it to the client.

- If your client code imports code with a secret, it will still be included in the client bundle. This also applies to ALL files in the `app` directory that are not a route handler (suffixed with `+api.js`).
- If your secret is in a `<...>+api.js` (Route Handler) file, it will not be included in the client bundle. This applies to all files that are imported in the route handler.
- The secret stripping takes place in `expo/metro-config` and requires this be used in your `metro.config.js`!

## Deployment

> This is experimental and subject to breaking changes. We have no continuous tests against this configuration.

Every cloud hosting provider needs a custom adapter to support the Expo server runtime. The following providers have unofficial/experimental support from the Expo team.

Before you deploy with third-parties, it's good to be familiar with the basics of the [`npx expo export`](/more/expo-cli#exporting) command. Specifically:

- `/dist` is the default export directory for Expo CLI.
- Files in `/public` will be copied to `/dist` on export.
- The `@expo/server` package is included with `expo` and delegates requests to the server routes.
- `@expo/server` does **not** inflate environment variables from `.env` files, these are expected to be loaded either by the hosting provider or the user.
- Metro is not included in the server.

### Express

<Step label="1">

Install the required dependencies:

<Terminal cmd={['$ yarn add -D express compression morgan']} />

</Step>

<Step label="2">

Export the website for production.

<Terminal cmd={['$ yarn expo export -p web']} />

</Step>

<Step label="3">

Write a server entry file that serves the static files and delegates requests to the server routes.

```js server.js
#!/usr/bin/env node

const path = require('path');
const { createRequestHandler } = require('@expo/server/build/vendor/express');

const express = require('express');
const compression = require('compression');
const morgan = require('morgan');

const BUILD_DIR = path.join(process.cwd(), 'dist');

const app = express();

app.use(compression());

// http://expressjs.com/en/advanced/best-practice-security.html#at-a-minimum-disable-x-powered-by-header
app.disable('x-powered-by');

process.env.NODE_ENV = 'production';

app.use(
  // Prevent access to expo functions as these may
  // contain sensitive information.
  [/^\/_expo\/functions($|\/)/, '/'],
  express.static(BUILD_DIR, {
    maxAge: '1h',
    extensions: ['html'],
  })
);

app.use(morgan('tiny'));

app.all(
  '*',
  createRequestHandler({
    build: BUILD_DIR,
  })
);
const port = process.env.PORT || 3000;

app.listen(port, () => {
  console.log(`Express server listening on port ${port}`);
});
```

</Step>

<Step label="4">

Start the server with `node`:

<Terminal cmd={['$ node server.js']} />

</Step>

### Netlify

> This is experimental and subject to breaking changes. We have no continuous tests against this configuration.

<Step label="1">

Create a server entry file, all requests will be delegated through this middleware. The exact file location is important.

```js netlify/functions/server.js
const { createRequestHandler } = require('@expo/server/build/vendor/netlify');

const handler = createRequestHandler({
  /* @info Points to the root `dist/` (output) folder */
  build: require('path').join(__dirname, '../../dist'),
  /* @end */
  mode: process.env.NODE_ENV,
});

module.exports = { handler };
```

</Step>

<Step label="2">

Create a Netlify configuration file to redirect all requests to the server function.

```yaml netlify.toml
[build]
  command = "expo export -p web"
  functions = "netlify/functions"
  publish = "dist"

[[redirects]]
  from = "/*"
  to = "/.netlify/functions/server"
  status = 404

[functions]
  # Include everything to ensure dynamic routes can be used.
  included_files = ["dist/**/*"]

[[headers]]
  for = "/dist/_expo/functions/*"
  [headers.values]
    # Set to 60 seconds as an example.
    "Cache-Control" = "public, max-age=60, s-maxage=60"
```

</Step>

<Step label="3">

After you have created the configuration files, you can build the website and functions with Expo CLI:

<Terminal cmd={['$ yarn expo export -p web']} />

</Step>

<Step label="4">

Deploy to Netlify with the [Netlify CLI](https://docs.netlify.com/cli/get-started/).

<Terminal
  cmd={[
    '# Install the Netlify CLI globally if needed.',
    '$ npm install netlify-cli -g',
    '# Deploy the website.',
    '$ netlify deploy',
  ]}
/>

You can now visit your website at the URL provided by Netlify CLI. Running `netlify deploy --prod` will publish to the production URL.

</Step>

<Step label="5">

If you're using any environment variables or `.env` files, you'll need to add them to Netlify. You can do this by going to the "Site settings" page and adding them to the "Build & deploy" section.

</Step>

[wcg-request]: https://fetch.spec.whatwg.org/#request
[wcg-response]: https://fetch.spec.whatwg.org/#response

## Open AI Example

> This guide is subject to move

<FileTree
  files={[
    ['app/index.tsx', 'User interface'],
    ['app/generate+api.ts', 'API route'],
    ['.env.local', 'Secret keys'],
  ]}
/>

<Step label="1">

First, create a new Open AI API key. You can do this by visiting the [Open AI dashboard](https://platform.openai.com/). Then add the key to your `.env.local` file.

```sh .env.local
OPENAI_API_KEY=sk-xxxxxx
```

This key should only ever be used in the server code. If you accidentally push it to the client, you can revoke it in the Open AI dashboard. You can manually validate the output by running `npx expo export` and searching for the key in the `/dist` folder.

</Step>

<Step label="2">

Create a new API route in the `app` directory, this route should be available at `/generate`:

```ts app/generate+api.ts
import { ExpoRequest, ExpoResponse } from 'expo-router/server';

export async function POST(req: ExpoRequest): Promise<ExpoResponse> {
  const { prompt } = await req.json();

  const payload = {
    prompt,
    max_tokens: 100, // You can customize this
  };

  const json = await fetch('https://api.openai.com/v1/engines/text-davinci-003/completions', {
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${process.env.OPENAI_API_KEY ?? ''}`,
    },
    method: 'POST',
    body: JSON.stringify(payload),
  }).then(res => res.json());

  return ExpoResponse.json(json);
}
```

You can test the API route by running the following terminal command (assuming you're hosting the app on the default port):

<Terminal
  cmd={[
    '$ curl -X POST -H "Content-Type: application/json" -d \'{"prompt":"Hello, my name is"}\' http://localhost:8081/generate',
  ]}
/>

</Step>

<Step label="3">

Finally, we'll create a simple UI with a text input and a submit button to generate the bios.

<Collapsible summary="Application code">

```js app/index.tsx
import React from 'react';
import { Button, StyleSheet, Text, TextInput, View } from 'react-native';

export { ErrorBoundary } from 'expo-router';

export default function Page() {
  const [loading, setLoading] = React.useState(false);
  const [value, setValue] = React.useState('');
  const [generatedBios, setGeneratedBios] = React.useState('');

  const generateBio = async () => {
    setGeneratedBios('');
    setLoading(true);

    const prompt = `Generate 2 twitter bios with no hashtags and clearly labeled "1." and "2.". Make sure each generated bio is at max 20 words and base it on this context: ${value}${
      value.slice(-1) === '.' ? '' : '.'
    }`;

    // Simply send the prompt to the API route.
    const response = await fetch('/generate', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        prompt,
      }),
    });

    if (!response.ok) {
      throw new Error(response.statusText);
    }

    const answer = await response.json();
    setGeneratedBios(answer.choices[0].text);
    setLoading(false);
  };

  return (
    <View style={styles.container}>
      <View style={styles.main}>
        <Text style={styles.title}>Twitter Bio AI</Text>

        <TextInput
          value={value}
          style={{ minHeight: 120, borderWidth: 1 }}
          onChange={e => setValue(e.nativeEvent.text)}
          rows={4}
          placeholderTextColor="#9CA3AF"
          placeholder="e.g. Expo Router enthusiast."
        />

        <Button
          disabled={loading}
          onPress={() => generateBio()}
          title={loading ? 'Loading...' : 'Generate your bio!'}
        />

        {generatedBios != null && (
          <>
            <Text style={styles.subtitle}>Generated Bios:</Text>
            {generatedBios
              .substring(generatedBios?.indexOf('1') + 2)
              .split('2.')
              .map((generatedBio, index) => (
                <Text key={String(index)}>{generatedBio}</Text>
              ))}
          </>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    padding: 24,
  },
  main: {
    flex: 1,
    gap: 8,
    justifyContent: 'center',
    maxWidth: 960,
    marginHorizontal: 'auto',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
  },
  subtitle: {
    fontSize: 36,
    color: '#38434D',
  },
});
```

</Collapsible>

</Step>

<Step label="4">

If you want to use the app on native, you'll need to configure the URL polyfill so the app knows what to preprend before `/generate`. The URL can be a placeholder in development, but it must be updated to the location where the API routes are hosted in production for the app to work outside of development.

```json app.json
{
  "plugins": [
    [
      "expo-router",
      {
        /* @info The URL where the API routes are hosted at. */
        "origin": "https://mywebsite.netlify.app/"
        /* @end */
      }
    ]
  ],
  "web": {
    "bundler": "metro",
    "output": "server"
  }
}
```

</Step>

<Step label="5">

Start the dev server to host the app.

<Terminal cmd={['$ npx expo']} />

You can now use the app on any device and start generating prompts!

</Step>

{"version":3,"names":["_warnOnce","_interopRequireDefault","require","_NativePerformanceObserver","_PerformanceEntry","_RawPerformanceEntry","PerformanceObserverEntryList","entries","_classCallCheck2","default","_entries","_createClass2","key","value","getEntries","getEntriesByType","type","filter","entry","entryType","getEntriesByName","name","undefined","exports","observerCountPerEntryType","Map","registeredObservers","isOnPerformanceEntryCallbackSet","onPerformanceEntry","_entryResult$entries","NativePerformanceObserver","entryResult","popPendingEntries","rawEntries","droppedEntriesCount","length","map","rawToPerformanceEntry","_loop","observerConfig","entriesForObserver","entryTypes","has","durationThreshold","get","duration","callback","observer","_ref","_ref2","_slicedToArray2","warnNoNativePerformanceObserver","warnOnce","applyDurationThresholds","durationThresholds","Array","from","values","config","reduce","accumulator","currentValue","union","_ref5","_ref4","setDurationThreshold","performanceEntryTypeToRaw","PerformanceObserver","_callback","observe","options","_registeredObservers$","_validateObserveOptions","requestedEntryTypes","_type","t","currentEntryTypes","nextEntryTypes","size","set","setOnPerformanceEntryCallback","newEntryTypes","difference","Set","keys","_observerCountPerEntr","rawType","startReporting","disconnect","_observerCountPerEntr2","numberOfObserversForThisType","delete","stopReporting","TypeError","Error","supportedEntryTypes","Object","freeze","a","b","res","_ref8","_ref7","k","v","_b$get","Math","min","_toConsumableArray2","x"],"sources":["PerformanceObserver.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict\n */\n\nimport type {HighResTimeStamp, PerformanceEntryType} from './PerformanceEntry';\n\nimport warnOnce from '../Utilities/warnOnce';\nimport NativePerformanceObserver from './NativePerformanceObserver';\nimport {PerformanceEntry} from './PerformanceEntry';\nimport {\n  performanceEntryTypeToRaw,\n  rawToPerformanceEntry,\n} from './RawPerformanceEntry';\n\nexport type PerformanceEntryList = $ReadOnlyArray<PerformanceEntry>;\n\nexport class PerformanceObserverEntryList {\n  _entries: PerformanceEntryList;\n\n  constructor(entries: PerformanceEntryList) {\n    this._entries = entries;\n  }\n\n  getEntries(): PerformanceEntryList {\n    return this._entries;\n  }\n\n  getEntriesByType(type: PerformanceEntryType): PerformanceEntryList {\n    return this._entries.filter(entry => entry.entryType === type);\n  }\n\n  getEntriesByName(\n    name: string,\n    type?: PerformanceEntryType,\n  ): PerformanceEntryList {\n    if (type === undefined) {\n      return this._entries.filter(entry => entry.name === name);\n    } else {\n      return this._entries.filter(\n        entry => entry.name === name && entry.entryType === type,\n      );\n    }\n  }\n}\n\nexport type PerformanceObserverCallback = (\n  list: PerformanceObserverEntryList,\n  observer: PerformanceObserver,\n  // The number of buffered entries which got dropped from the buffer due to the buffer being full:\n  droppedEntryCount?: number,\n) => void;\n\nexport type PerformanceObserverInit =\n  | {\n      entryTypes: Array<PerformanceEntryType>,\n    }\n  | {\n      type: PerformanceEntryType,\n      durationThreshold?: HighResTimeStamp,\n    };\n\ntype PerformanceObserverConfig = {|\n  callback: PerformanceObserverCallback,\n  // Map of {entryType: durationThreshold}\n  entryTypes: $ReadOnlyMap<PerformanceEntryType, ?number>,\n|};\n\nconst observerCountPerEntryType: Map<PerformanceEntryType, number> = new Map();\nconst registeredObservers: Map<PerformanceObserver, PerformanceObserverConfig> =\n  new Map();\nlet isOnPerformanceEntryCallbackSet: boolean = false;\n\n// This is a callback that gets scheduled and periodically called from the native side\nconst onPerformanceEntry = () => {\n  if (!NativePerformanceObserver) {\n    return;\n  }\n  const entryResult = NativePerformanceObserver.popPendingEntries();\n  const rawEntries = entryResult?.entries ?? [];\n  const droppedEntriesCount = entryResult?.droppedEntriesCount;\n  if (rawEntries.length === 0) {\n    return;\n  }\n  const entries = rawEntries.map(rawToPerformanceEntry);\n  for (const [observer, observerConfig] of registeredObservers.entries()) {\n    const entriesForObserver: PerformanceEntryList = entries.filter(entry => {\n      if (!observerConfig.entryTypes.has(entry.entryType)) {\n        return false;\n      }\n      const durationThreshold = observerConfig.entryTypes.get(entry.entryType);\n      return entry.duration >= (durationThreshold ?? 0);\n    });\n    observerConfig.callback(\n      new PerformanceObserverEntryList(entriesForObserver),\n      observer,\n      droppedEntriesCount,\n    );\n  }\n};\n\nexport function warnNoNativePerformanceObserver() {\n  warnOnce(\n    'missing-native-performance-observer',\n    'Missing native implementation of PerformanceObserver',\n  );\n}\n\nfunction applyDurationThresholds() {\n  const durationThresholds: Map<PerformanceEntryType, ?number> = Array.from(\n    registeredObservers.values(),\n  )\n    .map(config => config.entryTypes)\n    .reduce(\n      (accumulator, currentValue) => union(accumulator, currentValue),\n      new Map(),\n    );\n\n  for (const [entryType, durationThreshold] of durationThresholds) {\n    NativePerformanceObserver?.setDurationThreshold(\n      performanceEntryTypeToRaw(entryType),\n      durationThreshold ?? 0,\n    );\n  }\n}\n\n/**\n * Implementation of the PerformanceObserver interface for RN,\n * corresponding to the standard in https://www.w3.org/TR/performance-timeline/\n *\n * @example\n * const observer = new PerformanceObserver((list, _observer) => {\n *   const entries = list.getEntries();\n *   entries.forEach(entry => {\n *     reportEvent({\n *       eventName: entry.name,\n *       startTime: entry.startTime,\n *       endTime: entry.startTime + entry.duration,\n *       processingStart: entry.processingStart,\n *       processingEnd: entry.processingEnd,\n *       interactionId: entry.interactionId,\n *     });\n *   });\n * });\n * observer.observe({ type: \"event\" });\n */\nexport default class PerformanceObserver {\n  _callback: PerformanceObserverCallback;\n  _type: 'single' | 'multiple' | void;\n\n  constructor(callback: PerformanceObserverCallback) {\n    this._callback = callback;\n  }\n\n  observe(options: PerformanceObserverInit): void {\n    if (!NativePerformanceObserver) {\n      warnNoNativePerformanceObserver();\n      return;\n    }\n\n    this._validateObserveOptions(options);\n\n    let requestedEntryTypes;\n\n    if (options.entryTypes) {\n      this._type = 'multiple';\n      requestedEntryTypes = new Map(\n        options.entryTypes.map(t => [t, undefined]),\n      );\n    } else {\n      this._type = 'single';\n      requestedEntryTypes = new Map([\n        [options.type, options.durationThreshold],\n      ]);\n    }\n\n    // The same observer may receive multiple calls to \"observe\", so we need\n    // to check what is new on this call vs. previous ones.\n    const currentEntryTypes = registeredObservers.get(this)?.entryTypes;\n    const nextEntryTypes = currentEntryTypes\n      ? union(requestedEntryTypes, currentEntryTypes)\n      : requestedEntryTypes;\n\n    // This `observe` call is a no-op because there are no new things to observe.\n    if (currentEntryTypes && currentEntryTypes.size === nextEntryTypes.size) {\n      return;\n    }\n\n    registeredObservers.set(this, {\n      callback: this._callback,\n      entryTypes: nextEntryTypes,\n    });\n\n    if (!isOnPerformanceEntryCallbackSet) {\n      NativePerformanceObserver.setOnPerformanceEntryCallback(\n        onPerformanceEntry,\n      );\n      isOnPerformanceEntryCallbackSet = true;\n    }\n\n    // We only need to start listenening to new entry types being observed in\n    // this observer.\n    const newEntryTypes = currentEntryTypes\n      ? difference(\n          new Set(requestedEntryTypes.keys()),\n          new Set(currentEntryTypes.keys()),\n        )\n      : new Set(requestedEntryTypes.keys());\n    for (const type of newEntryTypes) {\n      if (!observerCountPerEntryType.has(type)) {\n        const rawType = performanceEntryTypeToRaw(type);\n        NativePerformanceObserver.startReporting(rawType);\n      }\n      observerCountPerEntryType.set(\n        type,\n        (observerCountPerEntryType.get(type) ?? 0) + 1,\n      );\n    }\n    applyDurationThresholds();\n  }\n\n  disconnect(): void {\n    if (!NativePerformanceObserver) {\n      warnNoNativePerformanceObserver();\n      return;\n    }\n\n    const observerConfig = registeredObservers.get(this);\n    if (!observerConfig) {\n      return;\n    }\n\n    // Disconnect this observer\n    for (const type of observerConfig.entryTypes.keys()) {\n      const numberOfObserversForThisType =\n        observerCountPerEntryType.get(type) ?? 0;\n      if (numberOfObserversForThisType === 1) {\n        observerCountPerEntryType.delete(type);\n        NativePerformanceObserver.stopReporting(\n          performanceEntryTypeToRaw(type),\n        );\n      } else if (numberOfObserversForThisType !== 0) {\n        observerCountPerEntryType.set(type, numberOfObserversForThisType - 1);\n      }\n    }\n\n    // Disconnect all observers if this was the last one\n    registeredObservers.delete(this);\n    if (registeredObservers.size === 0) {\n      NativePerformanceObserver.setOnPerformanceEntryCallback(undefined);\n      isOnPerformanceEntryCallbackSet = false;\n    }\n\n    applyDurationThresholds();\n  }\n\n  _validateObserveOptions(options: PerformanceObserverInit): void {\n    const {type, entryTypes, durationThreshold} = options;\n\n    if (!type && !entryTypes) {\n      throw new TypeError(\n        \"Failed to execute 'observe' on 'PerformanceObserver': An observe() call must not include both entryTypes and type arguments.\",\n      );\n    }\n\n    if (entryTypes && type) {\n      throw new TypeError(\n        \"Failed to execute 'observe' on 'PerformanceObserver': An observe() call must include either entryTypes or type arguments.\",\n      );\n    }\n\n    if (this._type === 'multiple' && type) {\n      throw new Error(\n        \"Failed to execute 'observe' on 'PerformanceObserver': This observer has performed observe({entryTypes:...}, therefore it cannot perform observe({type:...})\",\n      );\n    }\n\n    if (this._type === 'single' && entryTypes) {\n      throw new Error(\n        \"Failed to execute 'observe' on 'PerformanceObserver': This PerformanceObserver has performed observe({type:...}, therefore it cannot perform observe({entryTypes:...})\",\n      );\n    }\n\n    if (entryTypes && durationThreshold !== undefined) {\n      throw new TypeError(\n        \"Failed to execute 'observe' on 'PerformanceObserver': An observe() call must not include both entryTypes and durationThreshold arguments.\",\n      );\n    }\n  }\n\n  static supportedEntryTypes: $ReadOnlyArray<PerformanceEntryType> =\n    Object.freeze(['mark', 'measure', 'event']);\n}\n\n// As a Set union, except if value exists in both, we take minimum\nfunction union<T>(\n  a: $ReadOnlyMap<T, ?number>,\n  b: $ReadOnlyMap<T, ?number>,\n): Map<T, ?number> {\n  const res = new Map<T, ?number>();\n  for (const [k, v] of a) {\n    if (!b.has(k)) {\n      res.set(k, v);\n    } else {\n      res.set(k, Math.min(v ?? 0, b.get(k) ?? 0));\n    }\n  }\n  return res;\n}\n\nfunction difference<T>(a: $ReadOnlySet<T>, b: $ReadOnlySet<T>): Set<T> {\n  return new Set([...a].filter(x => !b.has(x)));\n}\n"],"mappings":"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"}
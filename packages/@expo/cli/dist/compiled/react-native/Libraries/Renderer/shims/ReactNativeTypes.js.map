{"version":3,"names":[],"sources":["ReactNativeTypes.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @noformat\n * @flow strict\n * @generated SignedSource<<265b342f0d29323bebb711ba0bc882ec>>\n *\n * This file was sync'd from the facebook/react repository.\n */\n\nimport type {ElementRef, ElementType, Element, AbstractComponent} from 'react';\n\nexport type MeasureOnSuccessCallback = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  pageX: number,\n  pageY: number,\n) => void;\n\nexport type MeasureInWindowOnSuccessCallback = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n) => void;\n\nexport type MeasureLayoutOnSuccessCallback = (\n  left: number,\n  top: number,\n  width: number,\n  height: number,\n) => void;\n\nexport type AttributeType<T, V> =\n  | true\n  | $ReadOnly<{\n      diff?: (arg1: T, arg2: T) => boolean,\n      process?: (arg1: V) => T,\n    }>;\n\n// We either force that `diff` and `process` always use mixed,\n// or we allow them to define specific types and use this hack\nexport type AnyAttributeType = AttributeType<$FlowFixMe, $FlowFixMe>;\n\nexport type AttributeConfiguration = $ReadOnly<{\n  [propName: string]: AnyAttributeType,\n  style: $ReadOnly<{\n    [propName: string]: AnyAttributeType,\n    ...\n  }>,\n  ...\n}>;\n\nexport type PartialAttributeConfiguration = $ReadOnly<{\n  [propName: string]: AnyAttributeType,\n  style?: $ReadOnly<{\n    [propName: string]: AnyAttributeType,\n    ...\n  }>,\n  ...\n}>;\n\nexport type ViewConfig = $ReadOnly<{\n  Commands?: $ReadOnly<{[commandName: string]: number, ...}>,\n  Constants?: $ReadOnly<{[name: string]: mixed, ...}>,\n  Manager?: string,\n  NativeProps?: $ReadOnly<{[propName: string]: string, ...}>,\n  baseModuleName?: ?string,\n  bubblingEventTypes?: $ReadOnly<{\n    [eventName: string]: $ReadOnly<{\n      phasedRegistrationNames: $ReadOnly<{\n        captured: string,\n        bubbled: string,\n        skipBubbling?: ?boolean,\n      }>,\n    }>,\n    ...\n  }>,\n  directEventTypes?: $ReadOnly<{\n    [eventName: string]: $ReadOnly<{\n      registrationName: string,\n    }>,\n    ...\n  }>,\n  uiViewClassName: string,\n  validAttributes: AttributeConfiguration,\n}>;\n\nexport type PartialViewConfig = $ReadOnly<{\n  bubblingEventTypes?: $PropertyType<ViewConfig, 'bubblingEventTypes'>,\n  directEventTypes?: $PropertyType<ViewConfig, 'directEventTypes'>,\n  uiViewClassName: string,\n  validAttributes?: PartialAttributeConfiguration,\n}>;\n\nexport type NativeMethods = $ReadOnly<{\n  blur(): void,\n  focus(): void,\n  measure(callback: MeasureOnSuccessCallback): void,\n  measureInWindow(callback: MeasureInWindowOnSuccessCallback): void,\n  measureLayout(\n    relativeToNativeNode: number | ElementRef<HostComponent<mixed>>,\n    onSuccess: MeasureLayoutOnSuccessCallback,\n    onFail?: () => void,\n  ): void,\n  setNativeProps(nativeProps: {...}): void,\n}>;\n\nexport type HostComponent<T> = AbstractComponent<T, $ReadOnly<NativeMethods>>;\n\ntype SecretInternalsType = {\n  computeComponentStackForErrorReporting(tag: number): string,\n  // TODO (bvaughn) Decide which additional types to expose here?\n  // And how much information to fill in for the above types.\n  ...\n};\n\ntype InspectorDataProps = $ReadOnly<{\n  [propName: string]: string,\n  ...\n}>;\n\ntype InspectorDataSource = $ReadOnly<{\n  fileName?: string,\n  lineNumber?: number,\n}>;\n\ntype InspectorDataGetter = (\n  <TElementType: ElementType>(\n    componentOrHandle: ElementRef<TElementType> | number,\n  ) => ?number,\n) => $ReadOnly<{\n  measure: (callback: MeasureOnSuccessCallback) => void,\n  props: InspectorDataProps,\n  source: InspectorDataSource,\n}>;\n\nexport type InspectorData = $ReadOnly<{\n  closestInstance?: mixed,\n  hierarchy: Array<{\n    name: ?string,\n    getInspectorData: InspectorDataGetter,\n  }>,\n  selectedIndex: ?number,\n  props: InspectorDataProps,\n  source: ?InspectorDataSource,\n}>;\n\nexport type TouchedViewDataAtPoint = $ReadOnly<{\n  pointerY: number,\n  touchedViewTag?: number,\n  frame: $ReadOnly<{\n    top: number,\n    left: number,\n    width: number,\n    height: number,\n  }>,\n  ...InspectorData,\n}>;\n\n/**\n * Flat ReactNative renderer bundles are too big for Flow to parse efficiently.\n * Provide minimal Flow typing for the high-level RN API and call it a day.\n */\nexport type ReactNativeType = {\n  findHostInstance_DEPRECATED<TElementType: ElementType>(\n    componentOrHandle: ?(ElementRef<TElementType> | number),\n  ): ?ElementRef<HostComponent<mixed>>,\n  findNodeHandle<TElementType: ElementType>(\n    componentOrHandle: ?(ElementRef<TElementType> | number),\n  ): ?number,\n  dispatchCommand(\n    handle: ElementRef<HostComponent<mixed>>,\n    command: string,\n    args: Array<mixed>,\n  ): void,\n  sendAccessibilityEvent(\n    handle: ElementRef<HostComponent<mixed>>,\n    eventType: string,\n  ): void,\n  render(\n    element: Element<ElementType>,\n    containerTag: number,\n    callback: ?() => void,\n  ): ?ElementRef<ElementType>,\n  unmountComponentAtNode(containerTag: number): void,\n  unmountComponentAtNodeAndRemoveContainer(containerTag: number): void,\n  unstable_batchedUpdates: <T>(fn: (T) => void, bookkeeping: T) => void,\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: SecretInternalsType,\n  ...\n};\n\nexport type ReactFabricType = {\n  findHostInstance_DEPRECATED<TElementType: ElementType>(\n    componentOrHandle: ?(ElementRef<TElementType> | number),\n  ): ?ElementRef<HostComponent<mixed>>,\n  findNodeHandle<TElementType: ElementType>(\n    componentOrHandle: ?(ElementRef<TElementType> | number),\n  ): ?number,\n  dispatchCommand(\n    handle: ElementRef<HostComponent<mixed>>,\n    command: string,\n    args: Array<mixed>,\n  ): void,\n  sendAccessibilityEvent(\n    handle: ElementRef<HostComponent<mixed>>,\n    eventType: string,\n  ): void,\n  render(\n    element: Element<ElementType>,\n    containerTag: number,\n    callback: ?() => void,\n    concurrentRoot: ?boolean,\n  ): ?ElementRef<ElementType>,\n  unmountComponentAtNode(containerTag: number): void,\n  ...\n};\n\nexport type ReactNativeEventTarget = {\n  node: {...},\n  canonical: {\n    _nativeTag: number,\n    viewConfig: ViewConfig,\n    currentProps: {...},\n    _internalInstanceHandle: {...},\n    ...\n  },\n  ...\n};\n\nexport type ReactFabricEventTouch = {\n  identifier: number,\n  locationX: number,\n  locationY: number,\n  pageX: number,\n  pageY: number,\n  screenX: number,\n  screenY: number,\n  target: number,\n  timestamp: number,\n  force: number,\n  ...\n};\n\nexport type ReactFabricEvent = {\n  touches: Array<ReactFabricEventTouch>,\n  changedTouches: Array<ReactFabricEventTouch>,\n  targetTouches: Array<ReactFabricEventTouch>,\n  target: number,\n  ...\n};\n\n// Imperative LayoutAnimation API types\n//\nexport type LayoutAnimationType =\n  | 'spring'\n  | 'linear'\n  | 'easeInEaseOut'\n  | 'easeIn'\n  | 'easeOut'\n  | 'keyboard';\n\nexport type LayoutAnimationProperty =\n  | 'opacity'\n  | 'scaleX'\n  | 'scaleY'\n  | 'scaleXY';\n\nexport type LayoutAnimationAnimationConfig = $ReadOnly<{\n  duration?: number,\n  delay?: number,\n  springDamping?: number,\n  initialVelocity?: number,\n  type?: LayoutAnimationType,\n  property?: LayoutAnimationProperty,\n}>;\n\nexport type LayoutAnimationConfig = $ReadOnly<{\n  duration: number,\n  create?: LayoutAnimationAnimationConfig,\n  update?: LayoutAnimationAnimationConfig,\n  delete?: LayoutAnimationAnimationConfig,\n}>;\n"],"mappings":""}
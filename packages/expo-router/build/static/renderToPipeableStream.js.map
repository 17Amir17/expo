{"version":3,"file":"renderToPipeableStream.js","sourceRoot":"","sources":["../../src/static/renderToPipeableStream.tsx"],"names":[],"mappings":";AAAA;;;;;GAKG;;;;;;AAEH,kDAA0B;AAC1B,qCAAiC;AAkB1B,KAAK,UAAU,sBAAsB,CAC1C,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,KAAK,EAAE,EAC5B,SAA0B;IAE1B,MAAM,EAAE,sBAAsB,EAAE,GAAG,OAAO,CAAC,sCAAsC,CAAC,CAAC;IAEnF,IAAI,CAAC,UAAG,CAAC,IAAI,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;QAC/B,MAAM,IAAI,KAAK,CACb,wBAAwB,GAAG,KAAK,GAAG,qBAAqB,GAAG,UAAG,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CACjF,CAAC;KACH;IAED,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,GAAG,MAAM,IAAA,UAAG,EAAC,KAAK,CAAC,CAAC;IAChD,OAAO,CAAC,GAAG,CAAC,mBAAmB,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;IACnD,uCAAuC;IAEvC,sBAAsB;IAEtB,0DAA0D;IAC1D,sCAAsC;IACtC,sCAAsC;IACtC,iCAAiC;IACjC,2CAA2C;IAC3C,cAAc;IACd,KAAK;IAEL,iCAAiC;IAEjC,mBAAmB;IACnB,yCAAyC;IACzC,sBAAsB;IACtB,0CAA0C;IAC1C,OAAO;IACP,aAAa;IACb,KAAK;IAEL,MAAM,aAAa,GAAG,IAAI,KAAK,CAC7B,EAAE,EACF;QACE,GAAG,CAAC,OAAO,EAAE,SAAiB;YAC5B,OAAO,CAAC,GAAG,CAAC,qBAAqB,EAAE,SAAS,CAAC,CAAC;YAC9C,OAAO,SAAS,CAAC,SAAS,CAAC,CAAC;YAC5B,iEAAiE;YACjE,sDAAsD;YACtD,0BAA0B;YAC1B,kDAAkD;QACpD,CAAC;KACF,CACF,CAAC;IAIF,cAAc;IAEd,MAAM,QAAQ,GAAG,eAAK,CAAC,aAAa,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;IACvD,OAAO,sBAAsB,CAAC,QAAQ,EAAE,aAAa,CAAC,CAAC;IAEvD,mBAAmB;IACnB,IAAI;IAEJ,qEAAqE;AACvE,CAAC;AA7DD,wDA6DC;AAED,mCAAkC;AAElC,KAAK,UAAU,MAAM,CAAC,IAAI;IACxB,MAAM,SAAS,GAAG,IAAI,cAAc,CAAC;QACnC,KAAK,CAAC,UAAU;YACd,IAAI,CACF,IAAI,iBAAQ,CAAC;gBACX,KAAK,CAAC,KAAK,EAAE,QAAQ,EAAE,QAAQ;oBAC7B,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;oBAC1B,QAAQ,EAAE,CAAC;gBACb,CAAC;gBACD,OAAO,CAAC,KAAK,EAAE,QAAQ;oBACrB,IAAI,KAAK,EAAE;wBACT,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;qBACzB;yBAAM;wBACL,UAAU,CAAC,KAAK,EAAE,CAAC;qBACpB;oBACD,QAAQ,CAAC,KAAK,CAAC,CAAC;gBAClB,CAAC;aACF,CAAC,CACH,CAAC;QACJ,CAAC;KACF,CAAC,CAAC;IAEH,MAAM,GAAG,GAAG,MAAM,SAAS,CAAC,SAAS,EAAE,CAAC,IAAI,EAAE,CAAC;IAC/C,OAAO,GAAG,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,IAAI,EAAE,CAAC;AACrC,CAAC","sourcesContent":["/**\n * Copyright Â© 2023 650 Industries.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport React from 'react';\nimport { ctx } from '../../_ctx';\n\ntype WebpackManifestSubType = {\n  // \"id\": \"./src/index.client.js\",\n  id: string;\n  // ['main']\n  chunks: string[];\n  // \"name\": \"\"\n  name: string;\n};\ntype WebpackManifest = {\n  // \"file:///Users/evanbacon/Documents/GitHub/server-components-demo/src/index.client.js\"\n  [filepath: string]: {\n    // \"*\"\n    [name: string]: WebpackManifestSubType;\n  };\n};\n\nexport async function renderToPipeableStream(\n  { $$route: route, ...props },\n  moduleMap: WebpackManifest\n) {\n  const { renderToReadableStream } = require('react-server-dom-webpack/server.edge');\n\n  if (!ctx.keys().includes(route)) {\n    throw new Error(\n      'Failed to find route: ' + route + '. Expected one of: ' + ctx.keys().join(', ')\n    );\n  }\n\n  const { default: Component } = await ctx(route);\n  console.log('Initial component', Component, route);\n  // const node = getNodeFinder()(route);\n\n  // if (node?._route) {\n\n  // const { default: Component } = node._route.loadRoute();\n  // const rsc = renderToPipeableStream(\n  //   // TODO: Does this support async?\n  //   // <Component {...props} />,\n  //   React.createElement(Component, props),\n  //   moduleMap\n  // );\n\n  // return await pipeTo(rsc.pipe);\n\n  // method === 'GET'\n  // const renderContext: RenderContext = {\n  //   rerender: () => {\n  //     throw new Error('Cannot rerender');\n  //   },\n  //   context,\n  // };\n\n  const bundlerConfig = new Proxy(\n    {},\n    {\n      get(_target, encodedId: string) {\n        console.log('Get manifest entry:', encodedId);\n        return moduleMap[encodedId];\n        // const [file, name] = encodedId.split('#') as [string, string];\n        // const id = resolveClientEntry(file, config, isDev);\n        // moduleIdCallback?.(id);\n        // return { id, chunks: [id], name, async: true };\n      },\n    },\n  );\n\n\n  \n  //   moduleMap\n\n  const elements = React.createElement(Component, props);\n  return renderToReadableStream(elements, bundlerConfig);\n\n  // return rsc.pipe;\n  // }\n\n  // throw new Error('Failed to render server component at: ' + route);\n}\n\nimport { Writable } from 'stream';\n\nasync function pipeTo(pipe) {\n  const rscStream = new ReadableStream({\n    start(controller) {\n      pipe(\n        new Writable({\n          write(chunk, encoding, callback) {\n            controller.enqueue(chunk);\n            callback();\n          },\n          destroy(error, callback) {\n            if (error) {\n              controller.error(error);\n            } else {\n              controller.close();\n            }\n            callback(error);\n          },\n        })\n      );\n    },\n  });\n\n  const res = await rscStream.getReader().read();\n  return res.value.toString().trim();\n}\n"]}
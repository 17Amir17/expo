diff --git a/node_modules/metro-file-map/src/index.js b/node_modules/metro-file-map/src/index.js
index 52de414..c43826b 100644
--- a/node_modules/metro-file-map/src/index.js
+++ b/node_modules/metro-file-map/src/index.js
@@ -1,59 +1,51 @@
-"use strict";
+'use strict';
 
-Object.defineProperty(exports, "__esModule", {
+Object.defineProperty(exports, '__esModule', {
   value: true,
 });
-Object.defineProperty(exports, "DiskCacheManager", {
+Object.defineProperty(exports, 'DiskCacheManager', {
   enumerable: true,
   get: function () {
     return _DiskCacheManager.DiskCacheManager;
   },
 });
 exports.DuplicateError = void 0;
-Object.defineProperty(exports, "DuplicateHasteCandidatesError", {
+Object.defineProperty(exports, 'DuplicateHasteCandidatesError', {
   enumerable: true,
   get: function () {
     return _DuplicateHasteCandidatesError.DuplicateHasteCandidatesError;
   },
 });
-Object.defineProperty(exports, "ModuleMap", {
+Object.defineProperty(exports, 'ModuleMap', {
   enumerable: true,
   get: function () {
     return _ModuleMap.default;
   },
 });
 exports.default = void 0;
-var _DiskCacheManager = require("./cache/DiskCacheManager");
-var _constants = _interopRequireDefault(require("./constants"));
-var _getMockName = _interopRequireDefault(require("./getMockName"));
-var _checkWatchmanCapabilities = _interopRequireDefault(
-  require("./lib/checkWatchmanCapabilities")
-);
-var _deepCloneRawModuleMap = _interopRequireDefault(
-  require("./lib/deepCloneRawModuleMap")
-);
-var fastPath = _interopRequireWildcard(require("./lib/fast_path"));
-var _getPlatformExtension = _interopRequireDefault(
-  require("./lib/getPlatformExtension")
-);
-var _normalizePathSep = _interopRequireDefault(
-  require("./lib/normalizePathSep")
-);
-var _TreeFS = _interopRequireDefault(require("./lib/TreeFS"));
-var _ModuleMap = _interopRequireDefault(require("./ModuleMap"));
-var _Watcher = require("./Watcher");
-var _worker = require("./worker");
-var _events = _interopRequireDefault(require("events"));
-var _invariant = _interopRequireDefault(require("invariant"));
-var _jestRegexUtil = require("jest-regex-util");
-var _jestWorker = require("jest-worker");
-var path = _interopRequireWildcard(require("path"));
-var _nodeAbortController = require("node-abort-controller");
-var _perf_hooks = require("perf_hooks");
-var _nullthrows = _interopRequireDefault(require("nullthrows"));
-var _DuplicateHasteCandidatesError = require("./lib/DuplicateHasteCandidatesError");
+var _DiskCacheManager = require('./cache/DiskCacheManager');
+var _constants = _interopRequireDefault(require('./constants'));
+var _getMockName = _interopRequireDefault(require('./getMockName'));
+var _checkWatchmanCapabilities = _interopRequireDefault(require('./lib/checkWatchmanCapabilities'));
+var _deepCloneRawModuleMap = _interopRequireDefault(require('./lib/deepCloneRawModuleMap'));
+var fastPath = _interopRequireWildcard(require('./lib/fast_path'));
+var _getPlatformExtension = _interopRequireDefault(require('./lib/getPlatformExtension'));
+var _normalizePathSep = _interopRequireDefault(require('./lib/normalizePathSep'));
+var _TreeFS = _interopRequireDefault(require('./lib/TreeFS'));
+var _ModuleMap = _interopRequireDefault(require('./ModuleMap'));
+var _Watcher = require('./Watcher');
+var _worker = require('./worker');
+var _events = _interopRequireDefault(require('events'));
+var _invariant = _interopRequireDefault(require('invariant'));
+var _jestRegexUtil = require('jest-regex-util');
+var _jestWorker = require('jest-worker');
+var path = _interopRequireWildcard(require('path'));
+var _nodeAbortController = require('node-abort-controller');
+var _perf_hooks = require('perf_hooks');
+var _nullthrows = _interopRequireDefault(require('nullthrows'));
+var _DuplicateHasteCandidatesError = require('./lib/DuplicateHasteCandidatesError');
 function _getRequireWildcardCache(nodeInterop) {
-  if (typeof WeakMap !== "function") return null;
+  if (typeof WeakMap !== 'function') return null;
   var cacheBabelInterop = new WeakMap();
   var cacheNodeInterop = new WeakMap();
   return (_getRequireWildcardCache = function (nodeInterop) {
@@ -64,7 +56,7 @@ function _interopRequireWildcard(obj, nodeInterop) {
   if (!nodeInterop && obj && obj.__esModule) {
     return obj;
   }
-  if (obj === null || (typeof obj !== "object" && typeof obj !== "function")) {
+  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
     return { default: obj };
   }
   var cache = _getRequireWildcardCache(nodeInterop);
@@ -72,13 +64,10 @@ function _interopRequireWildcard(obj, nodeInterop) {
     return cache.get(obj);
   }
   var newObj = {};
-  var hasPropertyDescriptor =
-    Object.defineProperty && Object.getOwnPropertyDescriptor;
+  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
   for (var key in obj) {
-    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
-      var desc = hasPropertyDescriptor
-        ? Object.getOwnPropertyDescriptor(obj, key)
-        : null;
+    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
+      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
       if (desc && (desc.get || desc.set)) {
         Object.defineProperty(newObj, key, desc);
       } else {
@@ -108,24 +97,22 @@ function _interopRequireDefault(obj) {
 
 // $FlowFixMe[untyped-import] - jest-regex-util
 
-const debug = require("debug")("Metro:FileMap");
+const debug = require('debug')('Metro:FileMap');
 // This should be bumped whenever a code change to `metro-file-map` itself
 // would cause a change to the cache data structure and/or content (for a given
 // filesystem state and build parameters).
-const CACHE_BREAKER = "4";
+const CACHE_BREAKER = '4';
 const CHANGE_INTERVAL = 30;
-const NODE_MODULES = path.sep + "node_modules" + path.sep;
-const PACKAGE_JSON = path.sep + "package.json";
-const VCS_DIRECTORIES = [".git", ".hg"]
-  .map((vcs) =>
-    (0, _jestRegexUtil.escapePathForRegex)(path.sep + vcs + path.sep)
-  )
-  .join("|");
+const NODE_MODULES = path.sep + 'node_modules' + path.sep;
+const PACKAGE_JSON = path.sep + 'package.json';
+const VCS_DIRECTORIES = ['.git', '.hg']
+  .map((vcs) => (0, _jestRegexUtil.escapePathForRegex)(path.sep + vcs + path.sep))
+  .join('|');
 const WATCHMAN_REQUIRED_CAPABILITIES = [
-  "field-content.sha1hex",
-  "relative_root",
-  "suffix-set",
-  "wildmatch",
+  'field-content.sha1hex',
+  'relative_root',
+  'suffix-set',
+  'wildmatch',
 ];
 
 /**
@@ -213,9 +200,8 @@ class HasteMap extends _events.default {
   constructor(options) {
     super();
     if (options.perfLoggerFactory) {
-      this._startupPerfLogger =
-        options.perfLoggerFactory?.("START_UP").subSpan("hasteMap") ?? null;
-      this._startupPerfLogger?.point("constructor_start");
+      this._startupPerfLogger = options.perfLoggerFactory?.('START_UP').subSpan('hasteMap') ?? null;
+      this._startupPerfLogger?.point('constructor_start');
     }
 
     // Add VCS_DIRECTORIES to provided ignorePattern
@@ -224,22 +210,17 @@ class HasteMap extends _events.default {
       const inputIgnorePattern = options.ignorePattern;
       if (inputIgnorePattern instanceof RegExp) {
         ignorePattern = new RegExp(
-          inputIgnorePattern.source.concat("|" + VCS_DIRECTORIES),
+          inputIgnorePattern.source.concat('|' + VCS_DIRECTORIES),
           inputIgnorePattern.flags
         );
       } else {
-        throw new Error(
-          "metro-file-map: the `ignorePattern` option must be a RegExp"
-        );
+        throw new Error('metro-file-map: the `ignorePattern` option must be a RegExp');
       }
     } else {
       ignorePattern = new RegExp(VCS_DIRECTORIES);
     }
     const buildParameters = {
-      computeDependencies:
-        options.computeDependencies == null
-          ? true
-          : options.computeDependencies,
+      computeDependencies: options.computeDependencies == null ? true : options.computeDependencies,
       computeSha1: options.computeSha1 || false,
       dependencyExtractor: options.dependencyExtractor ?? null,
       enableSymlinks: options.enableSymlinks || false,
@@ -248,7 +229,7 @@ class HasteMap extends _events.default {
       hasteImplModulePath: options.hasteImplModulePath,
       ignorePattern,
       mocksPattern:
-        options.mocksPattern != null && options.mocksPattern !== ""
+        options.mocksPattern != null && options.mocksPattern !== ''
           ? new RegExp(options.mocksPattern)
           : null,
       platforms: options.platforms,
@@ -277,12 +258,12 @@ class HasteMap extends _events.default {
         });
     this._buildPromise = null;
     this._worker = null;
-    this._startupPerfLogger?.point("constructor_end");
+    this._startupPerfLogger?.point('constructor_end');
     this._crawlerAbortController = new _nodeAbortController.AbortController();
     this._changeID = 0;
   }
   build() {
-    this._startupPerfLogger?.point("build_start");
+    this._startupPerfLogger?.point('build_start');
     if (!this._buildPromise) {
       this._buildPromise = (async () => {
         let initialData;
@@ -290,7 +271,7 @@ class HasteMap extends _events.default {
           initialData = await this.read();
         }
         if (!initialData) {
-          debug("Not using a cache");
+          debug('Not using a cache');
           initialData = {
             files: new Map(),
             map: new Map(),
@@ -300,19 +281,19 @@ class HasteMap extends _events.default {
           };
         } else {
           debug(
-            "Cache loaded (%d file(s), %d clock(s))",
+            'Cache loaded (%d file(s), %d clock(s))',
             initialData.files.size,
             initialData.clocks.size
           );
         }
         const rootDir = this._options.rootDir;
         const fileData = initialData.files;
-        this._startupPerfLogger?.point("constructFileSystem_start");
+        this._startupPerfLogger?.point('constructFileSystem_start');
         const fileSystem = new _TreeFS.default({
           files: fileData,
           rootDir,
         });
-        this._startupPerfLogger?.point("constructFileSystem_end");
+        this._startupPerfLogger?.point('constructFileSystem_end');
         const { map, mocks, duplicates } = initialData;
         const rawModuleMap = {
           duplicates,
@@ -332,7 +313,7 @@ class HasteMap extends _events.default {
           fileDelta.changedFiles,
           fileDelta.removedFiles
         );
-        debug("Finished mapping %d files.", fileData.size);
+        debug('Finished mapping %d files.', fileData.size);
         await this._watch(fileSystem, rawModuleMap);
         return {
           fileSystem,
@@ -341,7 +322,7 @@ class HasteMap extends _events.default {
       })();
     }
     return this._buildPromise.then((result) => {
-      this._startupPerfLogger?.point("build_end");
+      this._startupPerfLogger?.point('build_end');
       return result;
     });
   }
@@ -351,21 +332,18 @@ class HasteMap extends _events.default {
    */
   async read() {
     let data;
-    this._startupPerfLogger?.point("read_start");
+    this._startupPerfLogger?.point('read_start');
     try {
       data = await this._cacheManager.read();
     } catch (e) {
-      this._console.warn(
-        "Error while reading cache, falling back to a full crawl:\n",
-        e
-      );
+      this._console.warn('Error while reading cache, falling back to a full crawl:\n', e);
       this._startupPerfLogger?.annotate({
         string: {
           cacheReadError: e.toString(),
         },
       });
     }
-    this._startupPerfLogger?.point("read_end");
+    this._startupPerfLogger?.point('read_end');
     return data;
   }
 
@@ -373,7 +351,7 @@ class HasteMap extends _events.default {
    * 2. crawl the file system.
    */
   async _buildFileDelta(previousState) {
-    this._startupPerfLogger?.point("buildFileDelta_start");
+    this._startupPerfLogger?.point('buildFileDelta_start');
     const {
       computeSha1,
       enableSymlinks,
@@ -385,6 +363,7 @@ class HasteMap extends _events.default {
       watch,
       watchmanDeferStates,
     } = this._options;
+    console.log('WATCH:', roots, rootDir, ignorePattern);
     this._watcher = new _Watcher.Watcher({
       abortSignal: this._crawlerAbortController.signal,
       computeSha1,
@@ -404,9 +383,9 @@ class HasteMap extends _events.default {
       watchmanDeferStates,
     });
     const watcher = this._watcher;
-    watcher.on("status", (status) => this.emit("status", status));
+    watcher.on('status', (status) => this.emit('status', status));
     return watcher.crawl().then((result) => {
-      this._startupPerfLogger?.point("buildFileDelta_end");
+      this._startupPerfLogger?.point('buildFileDelta_end');
       return result;
     });
   }
@@ -431,20 +410,17 @@ class HasteMap extends _events.default {
       const existingModule = moduleMapItem[platform];
       if (
         existingModule &&
-        existingModule[_constants.default.PATH] !==
-          module[_constants.default.PATH]
+        existingModule[_constants.default.PATH] !== module[_constants.default.PATH]
       ) {
-        const method = this._options.throwOnModuleCollision ? "error" : "warn";
+        const method = this._options.throwOnModuleCollision ? 'error' : 'warn';
         this._console[method](
           [
-            "metro-file-map: Haste module naming collision: " + id,
-            "  The following files share their name; please adjust your hasteImpl:",
-            "    * <rootDir>" +
-              path.sep +
-              existingModule[_constants.default.PATH],
-            "    * <rootDir>" + path.sep + module[_constants.default.PATH],
-            "",
-          ].join("\n")
+            'metro-file-map: Haste module naming collision: ' + id,
+            '  The following files share their name; please adjust your hasteImpl:',
+            '    * <rootDir>' + path.sep + existingModule[_constants.default.PATH],
+            '    * <rootDir>' + path.sep + module[_constants.default.PATH],
+            '',
+          ].join('\n')
         );
         if (this._options.throwOnModuleCollision) {
           throw new DuplicateError(
@@ -465,10 +441,7 @@ class HasteMap extends _events.default {
         }
         const dups = new Map([
           [module[_constants.default.PATH], module[_constants.default.TYPE]],
-          [
-            existingModule[_constants.default.PATH],
-            existingModule[_constants.default.TYPE],
-          ],
+          [existingModule[_constants.default.PATH], existingModule[_constants.default.TYPE]],
         ]);
         dupsByPlatform.set(platform, dups);
         return;
@@ -477,10 +450,7 @@ class HasteMap extends _events.default {
       if (dupsByPlatform != null) {
         const dups = dupsByPlatform.get(platform);
         if (dups != null) {
-          dups.set(
-            module[_constants.default.PATH],
-            module[_constants.default.TYPE]
-          );
+          dups.set(module[_constants.default.PATH], module[_constants.default.TYPE]);
         }
         return;
       }
@@ -489,13 +459,11 @@ class HasteMap extends _events.default {
     const relativeFilePath = fastPath.relative(rootDir, filePath);
     const isSymlink = fileMetadata[_constants.default.SYMLINK] !== 0;
     const computeSha1 =
-      this._options.computeSha1 &&
-      !isSymlink &&
-      fileMetadata[_constants.default.SHA1] == null;
+      this._options.computeSha1 && !isSymlink && fileMetadata[_constants.default.SHA1] == null;
     const readLink =
       this._options.enableSymlinks &&
       isSymlink &&
-      typeof fileMetadata[_constants.default.SYMLINK] !== "string";
+      typeof fileMetadata[_constants.default.SYMLINK] !== 'string';
 
     // Callback called when the response from the worker is successful.
     const workerReply = (metadata) => {
@@ -508,7 +476,7 @@ class HasteMap extends _events.default {
       }
       fileMetadata[_constants.default.DEPENDENCIES] = metadata.dependencies
         ? metadata.dependencies.join(_constants.default.DEPENDENCY_DELIM)
-        : "";
+        : '';
       if (computeSha1) {
         fileMetadata[_constants.default.SHA1] = metadata.sha1;
       }
@@ -521,14 +489,14 @@ class HasteMap extends _events.default {
     const workerError = (error) => {
       if (
         error == null ||
-        typeof error !== "object" ||
+        typeof error !== 'object' ||
         error.message == null ||
         error.stack == null
       ) {
         // $FlowFixMe[reassign-const] - Refactor this
         error = new Error(error);
         // $FlowFixMe[incompatible-use] - error is mixed
-        error.stack = ""; // Remove stack for stack-less errors.
+        error.stack = ''; // Remove stack for stack-less errors.
       }
 
       throw error;
@@ -577,26 +545,21 @@ class HasteMap extends _events.default {
       }
       return null;
     }
-    if (
-      this._options.mocksPattern &&
-      this._options.mocksPattern.test(filePath)
-    ) {
+    if (this._options.mocksPattern && this._options.mocksPattern.test(filePath)) {
       const mockPath = (0, _getMockName.default)(filePath);
       const existingMockPath = moduleMap.mocks.get(mockPath);
       if (existingMockPath != null) {
         const secondMockPath = fastPath.relative(rootDir, filePath);
         if (existingMockPath !== secondMockPath) {
-          const method = this._options.throwOnModuleCollision
-            ? "error"
-            : "warn";
+          const method = this._options.throwOnModuleCollision ? 'error' : 'warn';
           this._console[method](
             [
-              "metro-file-map: duplicate manual mock found: " + mockPath,
-              "  The following files share their name; please delete one of them:",
-              "    * <rootDir>" + path.sep + existingMockPath,
-              "    * <rootDir>" + path.sep + secondMockPath,
-              "",
-            ].join("\n")
+              'metro-file-map: duplicate manual mock found: ' + mockPath,
+              '  The following files share their name; please delete one of them:',
+              '    * <rootDir>' + path.sep + existingMockPath,
+              '    * <rootDir>' + path.sep + secondMockPath,
+              '',
+            ].join('\n')
           );
           if (this._options.throwOnModuleCollision) {
             throw new DuplicateError(existingMockPath, secondMockPath);
@@ -619,44 +582,38 @@ class HasteMap extends _events.default {
       .then(workerReply, workerError);
   }
   async _applyFileDelta(fileSystem, moduleMap, delta) {
-    this._startupPerfLogger?.point("applyFileDelta_start");
+    this._startupPerfLogger?.point('applyFileDelta_start');
     const { changedFiles, removedFiles } = delta;
-    this._startupPerfLogger?.point("applyFileDelta_preprocess_start");
+    this._startupPerfLogger?.point('applyFileDelta_preprocess_start');
     const promises = [];
     const missingFiles = new Set();
 
     // Remove files first so that we don't mistake moved mocks or Haste
     // modules as duplicates.
-    this._startupPerfLogger?.point("applyFileDelta_remove_start");
+    this._startupPerfLogger?.point('applyFileDelta_remove_start');
     for (const [relativeFilePath] of removedFiles) {
       this._removeIfExists(fileSystem, moduleMap, relativeFilePath);
     }
-    this._startupPerfLogger?.point("applyFileDelta_remove_end");
+    this._startupPerfLogger?.point('applyFileDelta_remove_end');
     for (const [relativeFilePath, fileData] of changedFiles) {
       // A crawler may preserve the H.VISITED flag to indicate that the file
       // contents are unchaged and it doesn't need visiting again.
       if (fileData[_constants.default.VISITED] === 1) {
         continue;
       }
-      if (
-        this._options.skipPackageJson &&
-        relativeFilePath.endsWith(PACKAGE_JSON)
-      ) {
+      if (this._options.skipPackageJson && relativeFilePath.endsWith(PACKAGE_JSON)) {
         continue;
       }
 
       // SHA-1, if requested, should already be present thanks to the crawler.
-      const filePath = fastPath.resolve(
-        this._options.rootDir,
-        relativeFilePath
-      );
+      const filePath = fastPath.resolve(this._options.rootDir, relativeFilePath);
       const maybePromise = this._processFile(moduleMap, filePath, fileData, {
         perfLogger: this._startupPerfLogger,
       });
       if (maybePromise) {
         promises.push(
           maybePromise.catch((e) => {
-            if (["ENOENT", "EACCESS"].includes(e.code)) {
+            if (['ENOENT', 'EACCESS'].includes(e.code)) {
               missingFiles.add(relativeFilePath);
             } else {
               throw e;
@@ -665,16 +622,16 @@ class HasteMap extends _events.default {
         );
       }
     }
-    this._startupPerfLogger?.point("applyFileDelta_preprocess_end");
-    debug("Visiting %d added/modified files.", promises.length);
-    this._startupPerfLogger?.point("applyFileDelta_process_start");
+    this._startupPerfLogger?.point('applyFileDelta_preprocess_end');
+    debug('Visiting %d added/modified files.', promises.length);
+    this._startupPerfLogger?.point('applyFileDelta_process_start');
     try {
       await Promise.all(promises);
     } finally {
       this._cleanup();
     }
-    this._startupPerfLogger?.point("applyFileDelta_process_end");
-    this._startupPerfLogger?.point("applyFileDelta_add_start");
+    this._startupPerfLogger?.point('applyFileDelta_process_end');
+    this._startupPerfLogger?.point('applyFileDelta_add_start');
     for (const relativeFilePath of missingFiles) {
       // It's possible that a file could be deleted between being seen by the
       // crawler and our attempt to process it. For our purposes, this is
@@ -689,12 +646,12 @@ class HasteMap extends _events.default {
       this._removeIfExists(fileSystem, moduleMap, relativeFilePath);
     }
     fileSystem.bulkAddOrModify(changedFiles);
-    this._startupPerfLogger?.point("applyFileDelta_add_end");
-    this._startupPerfLogger?.point("applyFileDelta_end");
+    this._startupPerfLogger?.point('applyFileDelta_add_end');
+    this._startupPerfLogger?.point('applyFileDelta_end');
   }
   _cleanup() {
     const worker = this._worker;
-    if (worker && typeof worker.end === "function") {
+    if (worker && typeof worker.end === 'function') {
       // $FlowFixMe[unused-promise]
       worker.end();
     }
@@ -704,17 +661,9 @@ class HasteMap extends _events.default {
   /**
    * 4. Serialize a snapshot of our raw data via the configured cache manager
    */
-  async _takeSnapshotAndPersist(
-    fileSystem,
-    clocks,
-    moduleMap,
-    changed,
-    removed
-  ) {
-    this._startupPerfLogger?.point("persist_start");
-    const { map, duplicates, mocks } = (0, _deepCloneRawModuleMap.default)(
-      moduleMap
-    );
+  async _takeSnapshotAndPersist(fileSystem, clocks, moduleMap, changed, removed) {
+    this._startupPerfLogger?.point('persist_start');
+    const { map, duplicates, mocks } = (0, _deepCloneRawModuleMap.default)(moduleMap);
     await this._cacheManager.write(
       {
         files: fileSystem.getSerializableSnapshot(),
@@ -728,7 +677,7 @@ class HasteMap extends _events.default {
         removed,
       }
     );
-    this._startupPerfLogger?.point("persist_end");
+    this._startupPerfLogger?.point('persist_end');
   }
 
   /**
@@ -742,14 +691,14 @@ class HasteMap extends _events.default {
           worker: _worker.worker,
         };
       } else {
-        const workerPath = require.resolve("./worker");
-        perfLogger?.point("initWorkers_start");
+        const workerPath = require.resolve('./worker');
+        perfLogger?.point('initWorkers_start');
         this._worker = new _jestWorker.Worker(workerPath, {
-          exposedMethods: ["worker"],
+          exposedMethods: ['worker'],
           maxRetries: 3,
           numWorkers: this._options.maxWorkers,
         });
-        perfLogger?.point("initWorkers_end");
+        perfLogger?.point('initWorkers_end');
       }
     }
     return (0, _nullthrows.default)(this._worker);
@@ -764,10 +713,8 @@ class HasteMap extends _events.default {
       return;
     }
     const platform =
-      (0, _getPlatformExtension.default)(
-        relativeFilePath,
-        this._options.platforms
-      ) || _constants.default.GENERIC_PLATFORM;
+      (0, _getPlatformExtension.default)(relativeFilePath, this._options.platforms) ||
+      _constants.default.GENERIC_PLATFORM;
     const moduleMapItem = moduleMap.map.get(moduleName);
     if (moduleMapItem != null) {
       delete moduleMapItem[platform];
@@ -782,10 +729,7 @@ class HasteMap extends _events.default {
         this._options.rootDir,
         (0, _normalizePathSep.default)(relativeFilePath)
       );
-      if (
-        this._options.mocksPattern &&
-        this._options.mocksPattern.test(absoluteFilePath)
-      ) {
+      if (this._options.mocksPattern && this._options.mocksPattern.test(absoluteFilePath)) {
         const mockName = (0, _getMockName.default)(absoluteFilePath);
         moduleMap.mocks.delete(mockName);
       }
@@ -797,9 +741,9 @@ class HasteMap extends _events.default {
    * Watch mode
    */
   async _watch(fileSystem, moduleMap) {
-    this._startupPerfLogger?.point("watch_start");
+    this._startupPerfLogger?.point('watch_start');
     if (!this._options.watch) {
-      this._startupPerfLogger?.point("watch_end");
+      this._startupPerfLogger?.point('watch_end');
       return;
     }
 
@@ -815,29 +759,29 @@ class HasteMap extends _events.default {
     let eventStartTimestamp = null;
     const emitChange = () => {
       if (eventsQueue.length) {
-        const hmrPerfLogger = this._options.perfLoggerFactory?.("HMR", {
+        const hmrPerfLogger = this._options.perfLoggerFactory?.('HMR', {
           key: this._getNextChangeID(),
         });
         if (hmrPerfLogger != null) {
           hmrPerfLogger.start({
             timestamp: (0, _nullthrows.default)(eventStartTimestamp),
           });
-          hmrPerfLogger.point("waitingForChangeInterval_start", {
+          hmrPerfLogger.point('waitingForChangeInterval_start', {
             timestamp: (0, _nullthrows.default)(eventStartTimestamp),
           });
-          hmrPerfLogger.point("waitingForChangeInterval_end");
+          hmrPerfLogger.point('waitingForChangeInterval_end');
           hmrPerfLogger.annotate({
             int: {
               eventsQueueLength: eventsQueue.length,
             },
           });
-          hmrPerfLogger.point("fileChange_start");
+          hmrPerfLogger.point('fileChange_start');
         }
         const changeEvent = {
           logger: hmrPerfLogger,
           eventsQueue,
         };
-        this.emit("change", changeEvent);
+        this.emit('change', changeEvent);
         eventsQueue = [];
         eventStartTimestamp = null;
       }
@@ -846,18 +790,15 @@ class HasteMap extends _events.default {
       if (
         metadata &&
         // Ignore all directory events
-        (metadata.type === "d" ||
+        (metadata.type === 'd' ||
           // Ignore regular files with unwatched extensions
-          (metadata.type === "f" && !hasWatchedExtension(filePath)) ||
+          (metadata.type === 'f' && !hasWatchedExtension(filePath)) ||
           // Don't emit events relating to symlinks if enableSymlinks: false
-          (!this._options.enableSymlinks && metadata?.type === "l"))
+          (!this._options.enableSymlinks && metadata?.type === 'l'))
       ) {
         return;
       }
-      const absoluteFilePath = path.join(
-        root,
-        (0, _normalizePathSep.default)(filePath)
-      );
+      const absoluteFilePath = path.join(root, (0, _normalizePathSep.default)(filePath));
 
       // Ignore files (including symlinks) whose path matches ignorePattern
       // (we don't ignore node_modules in watch mode)
@@ -871,7 +812,7 @@ class HasteMap extends _events.default {
       // null, then it is assumed that the watcher does not have capabilities
       // to detect modified time, and change processing proceeds.
       if (
-        type === "change" &&
+        type === 'change' &&
         linkStats != null &&
         metadata &&
         metadata.modifiedTime != null &&
@@ -880,8 +821,7 @@ class HasteMap extends _events.default {
         return;
       }
       if (eventStartTimestamp == null) {
-        eventStartTimestamp =
-          _perf_hooks.performance.timeOrigin + _perf_hooks.performance.now();
+        eventStartTimestamp = _perf_hooks.performance.timeOrigin + _perf_hooks.performance.now();
       }
       changeQueue = changeQueue
         .then(async () => {
@@ -918,19 +858,19 @@ class HasteMap extends _events.default {
 
           // If the file was added or changed,
           // parse it and update the haste map.
-          if (type === "add" || type === "change") {
+          if (type === 'add' || type === 'change') {
             (0, _invariant.default)(
               metadata != null && metadata.size != null,
-              "since the file exists or changed, it should have metadata"
+              'since the file exists or changed, it should have metadata'
             );
             const fileMetadata = [
-              "",
+              '',
               metadata.modifiedTime,
               metadata.size,
               0,
-              "",
+              '',
               null,
-              metadata.type === "l" ? 1 : 0,
+              metadata.type === 'l' ? 1 : 0,
             ];
             try {
               await this._processFile(
@@ -945,7 +885,7 @@ class HasteMap extends _events.default {
               fileSystem.addOrModify(relativeFilePath, fileMetadata);
               enqueueEvent(metadata);
             } catch (e) {
-              if (!["ENOENT", "EACCESS"].includes(e.code)) {
+              if (!['ENOENT', 'EACCESS'].includes(e.code)) {
                 throw e;
               }
               // Swallow ENOENT/ACCESS errors silently. Safe because either:
@@ -955,7 +895,7 @@ class HasteMap extends _events.default {
               //   event for it, and we'll clean up in the usual way at that
               //   point.
             }
-          } else if (type === "delete") {
+          } else if (type === 'delete') {
             if (linkStats == null) {
               // Don't emit deletion events for files we weren't retaining.
               // This is expected for deletion of an ignored file.
@@ -967,22 +907,18 @@ class HasteMap extends _events.default {
               type: linkStats.fileType,
             });
           } else {
-            throw new Error(
-              `metro-file-map: Unrecognized event type from watcher: ${type}`
-            );
+            throw new Error(`metro-file-map: Unrecognized event type from watcher: ${type}`);
           }
           return null;
         })
         .catch((error) => {
-          this._console.error(
-            `metro-file-map: watch error:\n  ${error.stack}\n`
-          );
+          this._console.error(`metro-file-map: watch error:\n  ${error.stack}\n`);
         });
     };
     this._changeInterval = setInterval(emitChange, CHANGE_INTERVAL);
     (0, _invariant.default)(
       this._watcher != null,
-      "Expected _watcher to have been initialised by build()"
+      'Expected _watcher to have been initialised by build()'
     );
     await this._watcher.watch(onChange);
     if (this._options.healthCheck.enabled) {
@@ -991,11 +927,9 @@ class HasteMap extends _events.default {
           return;
         }
         // $FlowFixMe[unused-promise]
-        this._watcher
-          .checkHealth(this._options.healthCheck.timeout)
-          .then((result) => {
-            this.emit("healthCheck", result);
-          });
+        this._watcher.checkHealth(this._options.healthCheck.timeout).then((result) => {
+          this.emit('healthCheck', result);
+        });
       };
       performHealthCheck();
       this._healthCheckInterval = setInterval(
@@ -1003,7 +937,7 @@ class HasteMap extends _events.default {
         this._options.healthCheck.interval
       );
     }
-    this._startupPerfLogger?.point("watch_end");
+    this._startupPerfLogger?.point('watch_end');
   }
 
   /**
@@ -1020,10 +954,8 @@ class HasteMap extends _events.default {
       return;
     }
     const platform =
-      (0, _getPlatformExtension.default)(
-        relativeFilePath,
-        this._options.platforms
-      ) || _constants.default.GENERIC_PLATFORM;
+      (0, _getPlatformExtension.default)(relativeFilePath, this._options.platforms) ||
+      _constants.default.GENERIC_PLATFORM;
     let dups = dupsByPlatform.get(platform);
     if (dups == null) {
       return;
@@ -1069,11 +1001,9 @@ class HasteMap extends _events.default {
    * Helpers
    */
   _ignore(filePath) {
+    console.log('ignore:', filePath);
     const ignoreMatched = this._options.ignorePattern.test(filePath);
-    return (
-      ignoreMatched ||
-      (!this._options.retainAllFiles && filePath.includes(NODE_MODULES))
-    );
+    return ignoreMatched || (!this._options.retainAllFiles && filePath.includes(NODE_MODULES));
   }
   async _shouldUseWatchman() {
     if (!this._options.useWatchman) {
@@ -1089,7 +1019,7 @@ class HasteMap extends _events.default {
           // `useWatchman: false` here?
           this._startupPerfLogger?.annotate({
             string: {
-              watchmanFailedCapabilityCheck: e?.message ?? "[missing]",
+              watchmanFailedCapabilityCheck: e?.message ?? '[missing]',
             },
           });
           return false;
@@ -1108,7 +1038,7 @@ class HasteMap extends _events.default {
 exports.default = HasteMap;
 class DuplicateError extends Error {
   constructor(mockPath1, mockPath2) {
-    super("Duplicated files or mocks. Please check the console for more info");
+    super('Duplicated files or mocks. Please check the console for more info');
     this.mockPath1 = mockPath1;
     this.mockPath2 = mockPath2;
   }
diff --git a/node_modules/metro-file-map/src/lib/TreeFS.js b/node_modules/metro-file-map/src/lib/TreeFS.js
index bdc7c2c..7f9b84b 100644
--- a/node_modules/metro-file-map/src/lib/TreeFS.js
+++ b/node_modules/metro-file-map/src/lib/TreeFS.js
@@ -1,15 +1,15 @@
-"use strict";
+'use strict';
 
-Object.defineProperty(exports, "__esModule", {
+Object.defineProperty(exports, '__esModule', {
   value: true,
 });
 exports.default = void 0;
-var _constants = _interopRequireDefault(require("../constants"));
-var fastPath = _interopRequireWildcard(require("../lib/fast_path"));
-var _invariant = _interopRequireDefault(require("invariant"));
-var _path = _interopRequireDefault(require("path"));
+var _constants = _interopRequireDefault(require('../constants'));
+var fastPath = _interopRequireWildcard(require('../lib/fast_path'));
+var _invariant = _interopRequireDefault(require('invariant'));
+var _path = _interopRequireDefault(require('path'));
 function _getRequireWildcardCache(nodeInterop) {
-  if (typeof WeakMap !== "function") return null;
+  if (typeof WeakMap !== 'function') return null;
   var cacheBabelInterop = new WeakMap();
   var cacheNodeInterop = new WeakMap();
   return (_getRequireWildcardCache = function (nodeInterop) {
@@ -20,7 +20,7 @@ function _interopRequireWildcard(obj, nodeInterop) {
   if (!nodeInterop && obj && obj.__esModule) {
     return obj;
   }
-  if (obj === null || (typeof obj !== "object" && typeof obj !== "function")) {
+  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
     return { default: obj };
   }
   var cache = _getRequireWildcardCache(nodeInterop);
@@ -28,13 +28,10 @@ function _interopRequireWildcard(obj, nodeInterop) {
     return cache.get(obj);
   }
   var newObj = {};
-  var hasPropertyDescriptor =
-    Object.defineProperty && Object.getOwnPropertyDescriptor;
+  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
   for (var key in obj) {
-    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
-      var desc = hasPropertyDescriptor
-        ? Object.getOwnPropertyDescriptor(obj, key)
-        : null;
+    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
+      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
       if (desc && (desc.get || desc.set)) {
         Object.defineProperty(newObj, key, desc);
       } else {
@@ -92,18 +89,52 @@ class TreeFS {
     const fileMetadata = this._getFileData(mixedPath);
     if (fileMetadata) {
       return fileMetadata[_constants.default.DEPENDENCIES]
-        ? fileMetadata[_constants.default.DEPENDENCIES].split(
-            _constants.default.DEPENDENCY_DELIM
-          )
+        ? fileMetadata[_constants.default.DEPENDENCIES].split(_constants.default.DEPENDENCY_DELIM)
         : [];
     } else {
       return null;
     }
   }
+
   getSha1(mixedPath) {
-    const fileMetadata = this._getFileData(mixedPath);
-    return (fileMetadata && fileMetadata[_constants.default.SHA1]) ?? null;
+    let fileMetadata = this._getFileData(mixedPath);
+    const data = fileMetadata && fileMetadata[_constants.default.SHA1];
+    if (!data) {
+      // console.log('missing:', mixedPath);
+      // Watch file if it doesn't exist
+      const stat = require('fs').statSync(mixedPath);
+      const sha1 = mixedPath; // + require('fs').readFileSync(mixedPath, 'utf8');
+      this.addOrModify(mixedPath, [
+        /* id */ mixedPath,
+        // /* mtime */ ?number,
+        stat.mtimeMs,
+        // /* size */ number,
+        stat.size,
+        // /* visited */ 0 | 1,
+        0,
+        // /* dependencies */ string,
+        '',
+        // /* sha1 */ ?string,
+        sha1,
+        // /* symlink */ 0 | 1 | string, // string specifies target, if known
+        0,
+      ]);
+
+      if (!sha1) {
+        console.log('found but no sha', mixedPath);
+      }
+      return sha1;
+
+      // fileMetadata = this._getFileData(mixedPath);
+    }
+
+    return data;
   }
+
+  // getSha1(mixedPath) {
+  //   const fileMetadata = this._getFileData(mixedPath);
+  //   return (fileMetadata && fileMetadata[_constants.default.SHA1]) ?? null;
+  // }
   exists(mixedPath) {
     const result = this._getFileData(mixedPath);
     return result != null;
@@ -120,7 +151,7 @@ class TreeFS {
     if (fileMetadata == null) {
       return null;
     }
-    const fileType = fileMetadata[_constants.default.SYMLINK] === 0 ? "f" : "l";
+    const fileType = fileMetadata[_constants.default.SYMLINK] === 0 ? 'f' : 'l';
     const modifiedTime = fileMetadata[_constants.default.MTIME];
     return {
       fileType,
@@ -128,8 +159,7 @@ class TreeFS {
     };
   }
   matchFiles(pattern) {
-    const regexpPattern =
-      pattern instanceof RegExp ? pattern : new RegExp(pattern);
+    const regexpPattern = pattern instanceof RegExp ? pattern : new RegExp(pattern);
     const files = [];
     for (const filePath of this._pathIterator()) {
       const absolutePath = this._normalToAbsolutePath(filePath);
@@ -151,19 +181,16 @@ class TreeFS {
     if (!contextRootResult) {
       return [];
     }
-    const { canonicalPath: rootRealPath, node: contextRoot } =
-      contextRootResult;
+    const { canonicalPath: rootRealPath, node: contextRoot } = contextRootResult;
     if (!(contextRoot instanceof Map)) {
       return [];
     }
     const contextRootAbsolutePath =
-      rootRealPath === ""
-        ? this.#rootDir
-        : _path.default.join(this.#rootDir, rootRealPath);
+      rootRealPath === '' ? this.#rootDir : _path.default.join(this.#rootDir, rootRealPath);
     const files = [];
-    const prefix = "./";
+    const prefix = './';
     for (const relativePosixPath of this._pathIterator({
-      pathSep: "/",
+      pathSep: '/',
       recursive: context.recursive,
       rootNode: contextRoot,
       subtreeOnly: true,
@@ -177,9 +204,9 @@ class TreeFS {
         )
       ) {
         const relativePath =
-          _path.default.sep === "/"
+          _path.default.sep === '/'
             ? relativePosixPath
-            : relativePosixPath.replaceAll("/", _path.default.sep);
+            : relativePosixPath.replaceAll('/', _path.default.sep);
         files.push(contextRootAbsolutePath + _path.default.sep + relativePath);
       }
     }
@@ -203,22 +230,15 @@ class TreeFS {
     const normalPath = this._normalizePath(mixedPath);
     // Walk the tree to find the *real* path of the parent node, creating
     // directories as we need.
-    const parentDirNode = this._lookupByNormalPath(
-      _path.default.dirname(normalPath),
-      {
-        makeDirectories: true,
-      }
-    );
+    const parentDirNode = this._lookupByNormalPath(_path.default.dirname(normalPath), {
+      makeDirectories: true,
+    });
     if (!parentDirNode) {
-      throw new Error(
-        `TreeFS: Failed to make parent directory entry for ${mixedPath}`
-      );
+      throw new Error(`TreeFS: Failed to make parent directory entry for ${mixedPath}`);
     }
     // Normalize the resulting path to account for the parent node being root.
     const canonicalPath = this._normalizePath(
-      parentDirNode.canonicalPath +
-        _path.default.sep +
-        _path.default.basename(normalPath)
+      parentDirNode.canonicalPath + _path.default.sep + _path.default.basename(normalPath)
     );
     this.bulkAddOrModify(new Map([[canonicalPath, metadata]]));
   }
@@ -236,18 +256,15 @@ class TreeFS {
         files.set(normalPath, metadata);
       }
       const lastSepIdx = normalPath.lastIndexOf(_path.default.sep);
-      const dirname = lastSepIdx === -1 ? "" : normalPath.slice(0, lastSepIdx);
-      const basename =
-        lastSepIdx === -1 ? normalPath : normalPath.slice(lastSepIdx + 1);
+      const dirname = lastSepIdx === -1 ? '' : normalPath.slice(0, lastSepIdx);
+      const basename = lastSepIdx === -1 ? normalPath : normalPath.slice(lastSepIdx + 1);
       if (directoryNode == null || dirname !== lastDir) {
         const lookup = this._lookupByNormalPath(dirname, {
           followLeaf: false,
           makeDirectories: true,
         });
         if (!(lookup?.node instanceof Map)) {
-          throw new Error(
-            `TreeFS: Could not add directory ${dirname} when adding files`
-          );
+          throw new Error(`TreeFS: Could not add directory ${dirname} when adding files`);
         }
         lastDir = dirname;
         directoryNode = lookup.node;
@@ -255,15 +272,12 @@ class TreeFS {
       if (metadata[_constants.default.SYMLINK] !== 0) {
         const symlinkTarget = metadata[_constants.default.SYMLINK];
         (0, _invariant.default)(
-          typeof symlinkTarget === "string",
-          "expected symlink targets to be populated"
+          typeof symlinkTarget === 'string',
+          'expected symlink targets to be populated'
         );
         let rootRelativeSymlinkTarget;
         if (_path.default.isAbsolute(symlinkTarget)) {
-          rootRelativeSymlinkTarget = fastPath.relative(
-            this.#rootDir,
-            symlinkTarget
-          );
+          rootRelativeSymlinkTarget = fastPath.relative(this.#rootDir, symlinkTarget);
         } else {
           rootRelativeSymlinkTarget = _path.default.normalize(
             _path.default.join(_path.default.dirname(normalPath), symlinkTarget)
@@ -287,8 +301,7 @@ class TreeFS {
 
     // If node is a symlink, get its metadata from the file map. Otherwise, we
     // already have it in the lookup result.
-    const fileMetadata =
-      typeof node === "string" ? this.#files.get(canonicalPath) : node;
+    const fileMetadata = typeof node === 'string' ? this.#files.get(canonicalPath) : node;
     if (fileMetadata == null) {
       throw new Error(`TreeFS: Missing metadata for ${mixedPath}`);
     }
@@ -322,7 +335,7 @@ class TreeFS {
         ? targetNormalPath.slice(fromIdx)
         : targetNormalPath.slice(fromIdx, nextSepIdx);
       fromIdx = !isLastSegment ? nextSepIdx + 1 : targetNormalPath.length;
-      if (segmentName === ".") {
+      if (segmentName === '.') {
         continue;
       }
       let segmentNode = parentNode.get(segmentName);
@@ -336,10 +349,7 @@ class TreeFS {
 
       // If there are no more '/' to come, we're done unless this is a symlink
       // we must follow.
-      if (
-        isLastSegment &&
-        (typeof segmentNode !== "string" || opts.followLeaf === false)
-      ) {
+      if (isLastSegment && (typeof segmentNode !== 'string' || opts.followLeaf === false)) {
         return {
           canonicalPath: targetNormalPath,
           node: segmentNode,
@@ -353,7 +363,7 @@ class TreeFS {
       } else if (Array.isArray(segmentNode)) {
         // Regular file in a directory path
         return null;
-      } else if (typeof segmentNode === "string") {
+      } else if (typeof segmentNode === 'string') {
         // segmentNode is a normalised symlink target. Append any subsequent
         // path segments to the symlink target, and reset with our new target.
         targetNormalPath = isLastSegment
@@ -372,10 +382,7 @@ class TreeFS {
         parentNode = this.#rootNode;
       }
     }
-    (0, _invariant.default)(
-      parentNode === this.#rootNode,
-      "Unexpectedly escaped traversal"
-    );
+    (0, _invariant.default)(parentNode === this.#rootNode, 'Unexpectedly escaped traversal');
     return {
       canonicalPath: targetNormalPath,
       node: this.#rootNode,
@@ -388,10 +395,8 @@ class TreeFS {
       : _path.default.normalize(relativeOrAbsolutePath);
   }
   _normalToAbsolutePath(normalPath) {
-    if (normalPath[0] === ".") {
-      return _path.default.normalize(
-        this.#rootDir + _path.default.sep + normalPath
-      );
+    if (normalPath[0] === '.') {
+      return _path.default.normalize(this.#rootDir + _path.default.sep + normalPath);
     } else {
       return this.#rootDir + _path.default.sep + normalPath;
     }
@@ -411,12 +416,12 @@ class TreeFS {
     subtreeOnly = false,
   } = {}) {
     for (const [name, node] of rootNode ?? this.#rootNode) {
-      if (subtreeOnly && name === "..") {
+      if (subtreeOnly && name === '..') {
         continue;
       }
       if (Array.isArray(node)) {
         yield name;
-      } else if (typeof node === "string") {
+      } else if (typeof node === 'string') {
         const resolved = this._lookupByNormalPath(node);
         if (resolved == null) {
           continue;
@@ -459,10 +464,7 @@ class TreeFS {
   ) {
     const normalPath = this._normalizePath(filePath);
     const metadata = this.#files.get(normalPath);
-    if (
-      metadata &&
-      (!opts.followLeaf || metadata[_constants.default.SYMLINK] === 0)
-    ) {
+    if (metadata && (!opts.followLeaf || metadata[_constants.default.SYMLINK] === 0)) {
       return metadata;
     }
     const result = this._lookupByNormalPath(normalPath, {

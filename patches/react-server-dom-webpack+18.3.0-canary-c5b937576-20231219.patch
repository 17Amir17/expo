diff --git a/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js b/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js
index f2e4646..d69976d 100644
--- a/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js
+++ b/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js
@@ -154,6 +154,7 @@ function preloadModule(metadata) {
 
 function requireModule(metadata) {
   var moduleExports = __webpack_require__(metadata[ID]);
+  console.log('__webpack_require__', __webpack_require__, metadata, ID)
 
   if (isAsyncImport(metadata)) {
     if (typeof moduleExports.then !== 'function') ; else if (moduleExports.status === 'fulfilled') {
@@ -1368,11 +1369,13 @@ function initializeModuleChunk(chunk) {
 
 
 function reportGlobalError(response, error) {
+  
   response._chunks.forEach(function (chunk) {
     // If this chunk was already resolved or errored, it won't
     // trigger an error but if it wasn't then we need to
     // because we won't be getting any new data to resolve it.
     if (chunk.status === PENDING) {
+      console.log('ERROR>ON>CHUNK:', chunk)
       triggerErrorOnChunk(chunk, error);
     }
   });
@@ -1732,8 +1735,10 @@ function resolveModel(response, id, model) {
   var chunk = chunks.get(id);
 
   if (!chunk) {
+    console.log('| add chunk |:', id, model)
     chunks.set(id, createResolvedModelChunk(response, model));
   } else {
+    console.log('| resolve module chunk |:', id, model)
     resolveModelChunk(chunk, model);
   }
 }
@@ -1752,13 +1757,14 @@ function resolveModule(response, id, model) {
   var clientReference = resolveClientReference(response._bundlerConfig, clientReferenceMetadata);
   // For now we preload all modules as early as possible since it's likely
   // that we'll need them.
-
   var promise = preloadModule(clientReference);
 
+  console.log('| resolveModule |:', id, clientReference, promise)
   if (promise) {
     var blockedChunk;
 
     if (!chunk) {
+      console.log('| add chunk |:', id, clientReference)
       // Technically, we should just treat promise as the chunk in this
       // case. Because it'll just behave as any other promise.
       blockedChunk = createBlockedChunk(response);
@@ -1771,14 +1777,17 @@ function resolveModule(response, id, model) {
     }
 
     promise.then(function () {
+      console.log('>> RESOLVED MODULE', clientReference)
       return resolveModuleChunk(blockedChunk, clientReference);
     }, function (error) {
+      console.log('|> ERROR | Resolving client ref |:', clientReference, error)
       return triggerErrorOnChunk(blockedChunk, error);
     });
   } else {
     if (!chunk) {
       chunks.set(id, createResolvedModuleChunk(response, clientReference));
     } else {
+      console.log('IMPOSSIBLE HAPPENED!', chunk, clientReference);
       // This can't actually happen because we don't have any forward
       // references to modules.
       resolveModuleChunk(chunk, clientReference);
@@ -1808,6 +1817,65 @@ function resolveHint(response, code, model) {
   dispatchHint(code, hintModel);
 }
 
+function processFullRowFromString(response, id, tag, chunk) {
+  const row = chunk;
+
+  console.log('processFullRowFromString', id, tag, row)
+
+  switch (tag) {
+    case 73
+    /* "I" */
+    :
+      {
+        resolveModule(response, id, row);
+        return;
+      }
+
+    case 72
+    /* "H" */
+    :
+      {
+        var code = row[0];
+        resolveHint(response, code, row.slice(1));
+        return;
+      }
+
+    case 69
+    /* "E" */
+    :
+      {
+        var errorInfo = JSON.parse(row);
+
+        {
+          resolveErrorDev(response, id, errorInfo.digest, errorInfo.message, errorInfo.stack);
+        }
+
+        return;
+      }
+
+    case 84
+    /* "T" */
+    :
+      {
+        resolveText(response, id, row);
+        return;
+      }
+
+    case 80
+    /* "P" */
+    :
+    // Fallthrough
+
+    default:
+      /* """ "{" "[" "t" "f" "n" "0" - "9" */
+      {
+        // We assume anything else is JSON.
+        resolveModel(response, id, row);
+        return;
+      }
+  }
+}
+
 function processFullRow(response, id, tag, buffer, chunk) {
 
   var stringDecoder = response._stringDecoder;
@@ -1819,6 +1887,9 @@ function processFullRow(response, id, tag, buffer, chunk) {
 
   row += readFinalStringChunk(stringDecoder, chunk);
 
+  // 1, 73, [], [91, 34, ...], ["http://localhost:8081/node_modules/react-native-web/dist/exports/View/index.js.bundle?platform=web&dev=true&hot=false&transform.engine=hermes&transform.routerRoot=src%2Fapp&modulesOnly=true&runModule=false#-79164580",["http://localhost:8081/node_modules/react-native-web/dist/exports/View/index.js.bundle?platform=web&dev=true&hot=false&transform.engine=hermes&transform.routerRoot=src%2Fapp&modulesOnly=true&runModule=false#-79164580"],""]
+  // console.log('processFullRow', id, tag, buffer, chunk, row)
+
   switch (tag) {
     case 73
     /* "I" */
@@ -1854,6 +1925,7 @@ function processFullRow(response, id, tag, buffer, chunk) {
     /* "T" */
     :
       {
+        // console.log('resolveText', id, row)
         resolveText(response, id, row);
         return;
       }
@@ -2007,6 +2079,7 @@ function processBinaryChunk(response, chunk) {
 }
 
 function parseModel(response, json) {
+  // console.log('parseModel', json)
   return JSON.parse(json, response._fromJSON);
 }
 
@@ -2039,7 +2112,70 @@ function createResponseFromOptions(options) {
   );
 }
 
+function startReadingFromText(response, stream) {
+  // Hack: convert string to text and parse it as JSON.
+
+  function progress(_ref) {
+    console.log('progress:', _ref)
+    _ref.split('\n').filter(Boolean).forEach((buffer, index) => {
+
+      const line = buffer.match(/^([\d:A-Z]+)(.*)/)
+
+      const prefix = line[1];
+      const [, typeCode = 0] = prefix.split(':')
+      const cleanChunk = line[2];
+
+      let rowID = 0;
+      if (typeCode) {
+        // Convert char like "I" to 73
+        rowID = typeCode.charCodeAt(0)
+      }
+      const rowTag = Number(buffer[0]);
+
+      console.log('>>>LINE:', prefix, rowID, rowTag, cleanChunk)
+      // BACONHACK
+      processFullRowFromString(response, rowTag, rowID, cleanChunk)
+    })
+
+    close(response);
+  }
+
+  function error(e) {
+    reportGlobalError(response, e);
+  }
+
+  stream.text().then(progress).catch(error);
+
+
+  // var reader = stream.getReader();
+
+  // function progress(_ref) {
+  //   var done = _ref.done,
+  //       value = _ref.value;
+
+  //   if (done) {
+  //     close(response);
+  //     return;
+  //   }
+
+  //   var buffer = value;
+  //   processBinaryChunk(response, buffer);
+  //   return reader.read().then(progress).catch(error);
+  // }
+
+  // function error(e) {
+  //   reportGlobalError(response, e);
+  // }
+
+  // reader.read().then(progress).catch(error);
+}
+
 function startReadingFromStream(response, stream) {
+  // Hack: convert string to text and parse it as JSON.
+  console.log('startReadingFromStream', response, stream)
+  // var text = stream.read();
+// 
+
   var reader = stream.getReader();
 
   function progress(_ref) {
@@ -2072,7 +2208,15 @@ function createFromReadableStream(stream, options) {
 function createFromFetch(promiseForResponse, options) {
   var response = createResponseFromOptions(options);
   promiseForResponse.then(function (r) {
-    startReadingFromStream(response, r.body);
+    console.log(">>promiseForResponse:", !!r.body)
+    if (r.body) {
+
+      startReadingFromStream(response, r.body);
+    } else {
+    
+      startReadingFromText(response, r);
+
+    }
   }, function (e) {
     reportGlobalError(response, e);
   });
diff --git a/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.development.js b/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.development.js
index 5d78b6a..a63e228 100644
--- a/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.development.js
+++ b/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.development.js
@@ -2783,7 +2783,7 @@ function preloadModule(metadata) {
     return existingPromise;
   } else {
     // $FlowFixMe[unsupported-syntax]
-    var modulePromise = import(metadata.specifier);
+    var modulePromise = __r(metadata.specifier);
 
     if (metadata.async) {
       // If the module is async, it must have been a CJS module.
diff --git a/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.production.min.js b/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.production.min.js
index f52adc8..e8b924c 100644
--- a/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.production.min.js
+++ b/node_modules/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.production.min.js
@@ -61,7 +61,7 @@ function R(a,b){l=new Uint8Array(2048);m=0;p=!0;try{for(var d=a.completedImportC
 null;c++;break}g.splice(0,c)}finally{a.flushScheduled=!1,l&&0<m&&b.write(l.subarray(0,m)),l=null,m=0,p=!0}"function"===typeof b.flush&&b.flush();0===a.pendingChunks&&b.end()}function tb(a){a.flushScheduled=null!==a.destination;setImmediate(function(){return xa.run(a,ob,a)})}function lb(a){if(!1===a.flushScheduled&&0===a.pingedTasks.length&&null!==a.destination){var b=a.destination;a.flushScheduled=!0;setImmediate(function(){return R(a,b)})}}
 function ub(a,b){if(1===a.status)a.status=2,b.destroy(a.fatalError);else if(2!==a.status&&null===a.destination){a.destination=b;try{R(a,b)}catch(d){P(a,d),sb(a,d)}}}
 function vb(a,b){try{var d=a.abortableTasks;if(0<d.size){a.pendingChunks++;var c=a.nextChunkId++,e=void 0===b?Error("The render was aborted by the server without a reason."):b,f=P(a,e);Q(a,c,f,e);d.forEach(function(g){g.status=3;var k=T(c);g=pb(a,g.id,k);a.completedErrorChunks.push(g)});d.clear()}null!==a.destination&&R(a,a.destination)}catch(g){P(a,g),sb(a,g)}}function wb(a,b){var d=b.lastIndexOf("#");a=b.slice(0,d);b=b.slice(d+1);return{specifier:a,name:b}}var xb=new Map;
-function yb(a){var b=xb.get(a.specifier);if(b)return"fulfilled"===b.status?null:b;var d=import(a.specifier);a.async&&(d=d.then(function(c){return c.default}));d.then(function(c){var e=d;e.status="fulfilled";e.value=c},function(c){var e=d;e.status="rejected";e.reason=c});xb.set(a.specifier,d);return d}function W(a){var b=xb.get(a.specifier);if("fulfilled"===b.status)b=b.value;else throw b.reason;return"*"===a.name?b:""===a.name?b.default:b[a.name]}
+function yb(a){var b=xb.get(a.specifier);if(b)return"fulfilled"===b.status?null:b;var d=__r(a.specifier);a.async&&(d=d.then(function(c){return c.default}));d.then(function(c){var e=d;e.status="fulfilled";e.value=c},function(c){var e=d;e.status="rejected";e.reason=c});xb.set(a.specifier,d);return d}function W(a){var b=xb.get(a.specifier);if("fulfilled"===b.status)b=b.value;else throw b.reason;return"*"===a.name?b:""===a.name?b.default:b[a.name]}
 function zb(a,b,d,c){this.status=a;this.value=b;this.reason=d;this._response=c}zb.prototype=Object.create(Promise.prototype);zb.prototype.then=function(a,b){switch(this.status){case "resolved_model":Ab(this)}switch(this.status){case "fulfilled":a(this.value);break;case "pending":case "blocked":a&&(null===this.value&&(this.value=[]),this.value.push(a));b&&(null===this.reason&&(this.reason=[]),this.reason.push(b));break;default:b(this.reason)}};
 function Bb(a,b){for(var d=0;d<a.length;d++)(0,a[d])(b)}function Cb(a,b){if("pending"===a.status||"blocked"===a.status){var d=a.reason;a.status="rejected";a.reason=b;null!==d&&Bb(d,b)}}function Db(a,b,d,c,e,f){var g=wb(a._bundlerConfig,b);a=yb(g);if(d)d=Promise.all([d,a]).then(function(k){k=k[0];var h=W(g);return h.bind.apply(h,[null].concat(k))});else if(a)d=Promise.resolve(a).then(function(){return W(g)});else return W(g);d.then(Eb(c,e,f),Fb(c));return null}var X=null,Y=null;
 function Ab(a){var b=X,d=Y;X=a;Y=null;try{var c=JSON.parse(a.value,a._response._fromJSON);null!==Y&&0<Y.deps?(Y.value=c,a.status="blocked",a.value=null,a.reason=null):(a.status="fulfilled",a.value=c)}catch(e){a.status="rejected",a.reason=e}finally{X=b,Y=d}}function Gb(a,b){a._chunks.forEach(function(d){"pending"===d.status&&Cb(d,b)})}
